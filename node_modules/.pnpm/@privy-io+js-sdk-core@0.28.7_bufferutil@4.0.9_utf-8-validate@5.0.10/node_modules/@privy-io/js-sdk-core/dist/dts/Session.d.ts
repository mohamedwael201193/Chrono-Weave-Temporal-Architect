import EventEmitter from 'eventemitter3';
import type { PrivyAuthenticatedUser } from '@privy-io/public-api';
import type Storage from './storage/Storage';
type Opts = {
    appId: string;
    storage: Storage;
    isUsingServerCookies: boolean;
};
type SessionClearedReason = 'unknown' | 'logout' | 'set_with_non_string_value' | 'getToken_error' | 'getRefreshToken_error' | 'getIdentityToken_error' | 'getForkedToken_error' | 'session_update_action: clear' | 'missing_or_invalid_token';
type SessionOpts = {
    cookiesEnabled: boolean;
};
type SessionValueClearedOpts = {
    reason: SessionClearedReason;
};
type OAuthTokens = NonNullable<PrivyAuthenticatedUser['oauth_tokens']>;
export type OAuthTokensListener = (tokens: OAuthTokens) => void;
export type OAuthTokensSubscription = {
    unsubscribe: () => void;
};
type SessionEvent = {
    storage_cleared: [SessionValueClearedOpts];
    token_cleared: [SessionValueClearedOpts];
    refresh_token_cleared: [SessionValueClearedOpts];
    identity_token_cleared: [SessionValueClearedOpts];
    forked_token_cleared: [SessionValueClearedOpts];
    token_stored: [SessionOpts];
    refresh_token_stored: [SessionOpts];
    identity_token_stored: [SessionOpts];
    oauth_tokens_granted: [OAuthTokens];
};
/**
 * `Session` represents the session lifecycle of the login. It manages token
 * storage, refresh, and deletion.
 */
export declare class Session extends EventEmitter<SessionEvent> {
    static events: readonly ["storage_cleared", "token_cleared", "refresh_token_cleared", "identity_token_cleared", "forked_token_cleared", "token_stored", "refresh_token_stored", "identity_token_stored", "oauth_tokens_granted"];
    constructor(o: Opts);
    set isUsingServerCookies(isUsingServerCookies: boolean);
    getToken(): Promise<string | null>;
    getRefreshToken(): Promise<string | null>;
    getIdentityToken(): Promise<string | null>;
    getForkedToken(): Promise<string | null>;
    get mightHaveServerCookies(): boolean;
    /**
     * Checks to see if locally we have refresh credentials. Refresh
     * credentials consist of:
     *
     *     1. Client access token and refresh token
     *     2. Server cookies
     *
     * @returns true if we have what appear to be valid credentials, false otherwise.
     */
    hasRefreshCredentials(token: string | null, refreshToken: string | null): boolean;
    /**
     * Checks to see if locally we have recovery credentials (forked session token)
     *
     * @returns true if we have what appear to be valid credentials, false otherwise.
     */
    hasRecoveryCredentials(): Promise<boolean>;
    /**
     * Checks if the session contains a valid token that is not
     * expired or expiring soon.
     *
     * @returns true if token is considered active, false otherwise.
     */
    tokenIsActive(tokenRaw: string | null): boolean;
    /**
     * Accepts an optional options object to specify the reason storage is being cleared
     */
    destroyLocalState(opts?: {
        reason: SessionClearedReason;
    }): Promise<[void, void, void, void, void]>;
    storeToken(token: string | null): Promise<void>;
    private storeRefreshToken;
    updateWithTokensResponse(user: PrivyAuthenticatedUser): Promise<void>;
    processOAuthTokens(oAuthTokens: OAuthTokens | undefined): Promise<void>;
    storeIdentityToken(token: string | null | undefined): Promise<void>;
    /**
     * Get or create the local guest entropy, used to persist
     * accounts over multiple potential sessions.
     *
     * @returns The local guest accounts entropy.
     */
    getOrCreateGuestCredential(): Promise<string>;
    private clearForkedToken;
}
export {};
