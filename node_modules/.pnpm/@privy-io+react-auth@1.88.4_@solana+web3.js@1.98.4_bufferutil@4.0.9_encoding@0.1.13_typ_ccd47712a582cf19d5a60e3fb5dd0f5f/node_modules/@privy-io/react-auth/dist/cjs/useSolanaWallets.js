"use strict";var e=require("./privy-context.js"),t=require("@ethersproject/logger"),a=require("eventemitter3"),s=require("./user.js");function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var n,i,o=r(a);(i=n||(n={})).MISSING_OR_INVALID_PRIVY_APP_ID="missing_or_invalid_privy_app_id",i.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID="missing_or_invalid_privy_account_id",i.INVALID_DATA="invalid_data",i.LINKED_TO_ANOTHER_USER="linked_to_another_user",i.ALLOWLIST_REJECTED="allowlist_rejected",i.OAUTH_USER_DENIED="oauth_user_denied",i.UNKNOWN_AUTH_ERROR="unknown_auth_error",i.USER_EXITED_AUTH_FLOW="exited_auth_flow",i.MUST_BE_AUTHENTICATED="must_be_authenticated",i.UNKNOWN_CONNECT_WALLET_ERROR="unknown_connect_wallet_error",i.GENERIC_CONNECT_WALLET_ERROR="generic_connect_wallet_error",i.CLIENT_REQUEST_TIMEOUT="client_request_timeout",i.INVALID_CREDENTIALS="invalid_credentials";class l extends Error{toString(){return`${this.type}${this.privyErrorCode?`-${this.privyErrorCode}`:""}: ${this.message}${this.cause?` [cause: ${this.cause}]`:""}`}constructor(e,t,a){super(e),t instanceof Error&&(this.cause=t),this.privyErrorCode=a}}class d extends l{constructor(e,t,a){super(e),this.type="provider_error",this.code=t,this.data=a}}let c={UNKNOWN_ERROR:{eipCode:0,message:"Unknown error",detail:"Unknown error",retryable:!0},E4001_DEFAULT_USER_REJECTED_REQUEST:{eipCode:4001,message:"User Rejected Request",detail:"The user rejected the request.",default:!0,retryable:!0},E4100_DEFAULT_UNAUTHORIZED:{eipCode:4100,message:"Unauthorized",detail:"The requested method and/or account has not been authorized by the user.",default:!0,retryable:!1},E4200_DEFAULT_UNSUPPORTED_METHOD:{eipCode:4200,message:"Unsupported Method",detail:"The Provider does not support the requested method.",default:!0,retryable:!1},E4900_DEFAULT_DISCONNECTED:{eipCode:4900,message:"Disconnected",detail:"The Provider is disconnected from all chains.",default:!0,retryable:!0},E4901_DEFAULT_CHAIN_DISCONNECTED:{eipCode:4901,message:"Chain Disconnected",detail:"The Provider is not connected to the requested chain.",default:!0,retryable:!0},E32700_DEFAULT_PARSE_ERROR:{eipCode:-32700,message:"Parse error",detail:"Invalid JSON",default:!0,retryable:!1},E32600_DEFAULT_INVALID_REQUEST:{eipCode:-32600,message:"Invalid request",detail:"JSON is not a valid request object",default:!0,retryable:!1},E32601_DEFAULT_METHOD_NOT_FOUND:{eipCode:-32601,message:"Method not found",detail:"Method does not exist",default:!0,retryable:!1},E32602_DEFAULT_INVALID_PARAMS:{eipCode:-32602,message:"Invalid params",detail:"Invalid method parameters",default:!0,retryable:!1},E32603_DEFAULT_INTERNAL_ERROR:{eipCode:-32603,message:"Internal error",detail:"Internal JSON-RPC error",default:!0,retryable:!0},E32000_DEFAULT_INVALID_INPUT:{eipCode:-32e3,message:"Invalid input",detail:"Missing or invalid parameters",default:!0,retryable:!1},E32001_DEFAULT_RESOURCE_NOT_FOUND:{eipCode:-32001,message:"Resource not found",detail:"Requested resource not found",default:!0,retryable:!1},E32002_DEFAULT_RESOURCE_UNAVAILABLE:{eipCode:-32002,message:"Resource unavailable",detail:"Requested resource not available",default:!0,retryable:!0},E32003_DEFAULT_TRANSACTION_REJECTED:{eipCode:-32003,message:"Transaction rejected",detail:"Transaction creation failed",default:!0,retryable:!0},E32004_DEFAULT_METHOD_NOT_SUPPORTED:{eipCode:-32004,message:"Method not supported",detail:"Method is not implemented",default:!0,retryable:!1},E32005_DEFAULT_LIMIT_EXCEEDED:{eipCode:-32005,message:"Limit exceeded",detail:"Request exceeds defined limit",default:!0,retryable:!1},E32006_DEFAULT_JSON_RPC_VERSION_NOT_SUPPORTED:{eipCode:-32006,message:"JSON-RPC version not supported",detail:"Version of JSON-RPC protocol is not supported",default:!0,retryable:!1},E32002_CONNECTION_ALREADY_PENDING:{eipCode:-32002,message:"Connection request already pending",detail:"Don’t see your wallet? Check your other browser windows.",retryable:!1},E32002_REQUEST_ALREADY_PENDING:{eipCode:-32002,message:"Resource request already pending",detail:"Don’t see your wallet? Check your other browser windows.",retryable:!1},E32002_WALLET_LOCKED:{eipCode:-32002,message:"Wallet might be locked",detail:"Don’t see your wallet? Check your other browser windows.",retryable:!1},E4001_USER_REJECTED_REQUEST:{eipCode:4001,message:"Signature rejected",detail:"Please try signing again.",retryable:!0}};class E extends e.PrivyConnectorError{constructor(){super("Wallet timeout"),this.type="wallet_error"}}class _ extends e.PrivyConnectorError{constructor(){super("User rejected connection"),this.type="wallet_error"}}const u=a=>{if(a instanceof e.PrivyConnectorError)return a;if(a?.code&&a?.reason){let e=new p(a);return a.code===t.ErrorCode.ACTION_REJECTED&&(e.details=c.E4001_USER_REJECTED_REQUEST),e}return a?.code?new p(a):new e.PrivyConnectorError("Unknown connector error",a)};class h extends e.PrivyError{constructor(e,t,a){super(e),this.type="provider_error",this.code=t,this.data=a}}class p extends h{constructor(e){super(e.message,e.code,e.data);let t=Object.values(c).find((t=>t.eipCode===e.code));this.details=t||c.UNKNOWN_ERROR,-32002===e.code&&(e.message?.includes("already pending for origin")?e.message?.includes("wallet_requestPermissions")?this.details=c.E32002_CONNECTION_ALREADY_PENDING:this.details=c.E32002_REQUEST_ALREADY_PENDING:e.message?.includes("Already processing")&&e.message.includes("eth_requestAccounts")&&(this.details=c.E32002_WALLET_LOCKED))}}const y={ERROR_USER_EXISTS:{message:"User already exists for this address",detail:"Try another address!",retryable:!1},ERROR_TIMED_OUT:{message:"Wallet request timed out",detail:"Please try connecting again.",retryable:!0},ERROR_WALLET_CONNECTION:{message:"Could not log in with wallet",detail:"Please try connecting again.",retryable:!0},ERROR_USER_REJECTED_CONNECTION:{message:"You rejected the request",detail:"Please try connecting again.",retryable:!0},ERROR_USER_LIMIT_REACHED:{message:"Unable to link",detail:"You've reached the maximum number of linked wallets.",retryable:!1},...c};class C extends o.default{constructor(e){super(),this.walletClientType=e,this.connected=!1,this.initialized=!1}}const T=["metamask","phantom","brave_wallet","rainbow","uniswap_wallet_extension","uniswap_extension","rabby_wallet","crypto.com_wallet_extension","coinbase_wallet","coinbase_smart_wallet","metamask","trust","safe","rainbow","uniswap","zerion","argent","spot","omni","cryptocom","blockchain","safepal","bitkeep","zengo","1inch","binance","exodus","mew_wallet","alphawallet","keyring_pro","mathwallet","unstoppable","obvious","ambire","internet_money_wallet","coin98","abc_wallet","arculus_wallet","haha","cling_wallet","broearn","copiosa","burrito_wallet","enjin_wallet","plasma_wallet","avacus","bee","pitaka","pltwallet","minerva","kryptogo","prema","slingshot","kriptonio","timeless","secux","bitizen","blocto","okx_wallet","safemoon","rabby_wallet","privy","unknown","phantom","solflare","glow"];exports.ConnectorErrors=y,exports.E=c,exports.PrivyProviderRpcError=p,exports.ProviderRpcError=h,exports.SolanaWalletConnector=class extends C{get isInstalled(){return"Installed"===this.adapter.readyState}buildConnectedWallet(t,a){let s,r,n;if("Installed"!==t.readyState||!t.publicKey)throw Error("Wallet is not connected.");return"signMessage"in t&&(s=async(...e)=>{if(!t.connected)throw Error("Wallet is not connected.");return await t.signMessage(e[0])}),"sendTransaction"in t&&(r=async(...e)=>await t.sendTransaction(e[0],e[1],e[2])),"signTransaction"in t&&(n=async e=>await t.signTransaction(e)),{type:"solana",address:t.publicKey.toBase58(),meta:a,imported:!1,connectedAt:Date.now(),walletClientType:this.walletClientType,connectorType:this.connectorType,isConnected:async()=>t.connected,disconnect:()=>{try{t.disconnect()}catch(e){console.error("Wallet does not support programmatic disconnect")}},getProvider:e.notImplemented,signMessage:s,sendTransaction:r,signTransaction:n}}async syncAccounts(){if("Installed"===this.adapter.readyState&&this.adapter.publicKey){let e={name:this.walletBranding.name,icon:"string"==typeof this.walletBranding.icon?this.walletBranding.icon:void 0,id:this.walletBranding.id};this.wallets.find((e=>this.adapter.publicKey&&e.address===this.adapter.publicKey.toBase58()))||(this.wallets=[this.buildConnectedWallet(this.adapter,e)],this.emit("walletsUpdated"))}else this.wallets.length>0&&(this.wallets=[],this.emit("walletsUpdated"))}get walletBranding(){return{id:this.adapter.name,name:this.adapter.name,icon:this.adapter.icon}}async initialize(){this.subscribeListeners(),await this.syncAccounts(),this.shouldAutoConnect&&await this.adapter.autoConnect().catch(console.error),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}async getConnectedWallet(){return this.wallets.sort(((e,t)=>t.connectedAt-e.connectedAt))[0]||null}async isConnected(){return this.adapter.connected&&["Installed"].includes(this.adapter.readyState)}subscribeListeners(){this.adapter.addListener("disconnect",this.onDisconnect),this.adapter.addListener("connect",this.onConnect),this.adapter.addListener("error",this.onError),this.adapter.addListener("readyStateChange",this.onReadyStateChange)}unsubscribeListeners(){this.adapter.removeAllListeners()}constructor(e,t){super(function(e){return T.includes(e)}(e.name.toLowerCase())?e.name.toLowerCase():"unknown"),this.chainType="solana",this.connectorType="solana_adapter",this.disconnect=()=>{this.adapter.disconnect().then((()=>this.onDisconnect())).catch((e=>console.error("Error disconnecting",e)))},this.promptConnection=async()=>{try{await this.adapter.connect()}catch(e){throw u(e)}},this.onDisconnect=()=>{this.syncAccounts()},this.onConnect=e=>{this.syncAccounts()},this.onError=e=>{this.syncAccounts()},this.onReadyStateChange=e=>{"Installed"!==e&&(this.connected=!1),this.syncAccounts()},this.adapter=e,this.shouldAutoConnect=t,this.wallets=[]}},exports.UserRejectedConnectionError=_,exports.WalletConnector=C,exports.WalletTimeoutError=E,exports.formatConnectorError=u,exports.isBaseConnectedSolanaWallet=function(e){return"solana"===e.type},exports.isSolanaWalletConnector=function(e){return"solana"===e.chainType},exports.l=class extends d{constructor(e){super(e.message,e.code,e.data);let t=Object.values(c).find((t=>t.eipCode===e.code));this.details=t||c.UNKNOWN_ERROR,-32002===e.code&&(e.message?.includes("already pending for origin")?e.message?.includes("wallet_requestPermissions")?this.details=c.E32002_CONNECTION_ALREADY_PENDING:this.details=c.E32002_REQUEST_ALREADY_PENDING:e.message?.includes("Already processing")&&e.message.includes("eth_requestAccounts")&&(this.details=c.E32002_WALLET_LOCKED))}},exports.useSolanaWallets=()=>{let{embeddedSolanaWallet:t,exportSolanaWallet:a,createEmbeddedSolanaWallet:r,solanaWallets:n,initDelegateAction:i}=e.usePrivyInternal(),{user:o}=e.usePrivy();return{createWallet:r,exportWallet:a,delegateWalletAction:async()=>{let t=s.getPrivySolanaWallet(o);if(!t)throw new e.PrivyClientError("User must have a solana wallet in order to delegate actions");return await i({address:t.address})},wallets:n.concat(t?[t]:[])}};
