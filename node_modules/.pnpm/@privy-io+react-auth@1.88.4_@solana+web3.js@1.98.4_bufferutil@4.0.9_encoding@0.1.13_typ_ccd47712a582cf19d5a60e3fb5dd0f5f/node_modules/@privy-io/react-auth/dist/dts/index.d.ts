import * as react from 'react';
import react__default, { MouseEvent } from 'react';
import { C as Chain, W as WalletConnector, B as BaseConnectedEthereumWallet, a as RpcConfig, P as PrivyProxyProvider, E as Embedded1193Provider, b as WalletClientType, c as ConnectedWalletMetadata, d as ConnectorType, e as WalletListEntry, f as ExternalWalletsConfig, g as BaseConnectedWallet, S as SolanaWalletConnector, h as EIP1193Provider, U as User, O as OAuthTokens, i as OAuthProviderType, M as MoonpaySignRequest, j as MoonpaySignResponse, k as SmartWalletConfig, l as PrivyServerConfig, m as PrivyFarcasterSignerInitResponse, L as LoginMethod, n as SiweWalletMetadata, T as TelegramAuthResult, o as OAuthUserInfo, p as PrivyClientConfig, q as ConnectWalletModalOptions, r as LoginModalOptions, s as CreateWalletOptions, t as Wallet, u as SetWalletRecoveryOptions, v as SignMessageModalUIOptions, w as SignTypedDataParams, x as MfaMethod, y as UnsignedTransactionRequest, z as SendTransactionModalUIOptions, F as FundWalletConfig, A as TransactionReceipt, D as ConnectedWallet, G as PrivyIframeErrorTypesType, H as PrivyErrorCode, I as LinkedAccountWithMetadata, J as UserRecoveryMethod, K as FundingMethod, N as OAuthFlowState, Q as LoginWithCode, V as OtpFlowState, X as PasskeyFlowState, Y as SiweFlowState, Z as UnsignedTransactionRequestWithChainId, _ as CustomAuthFlowState } from './types.js';
export { ag as Apple, aq as AppleOAuthWithMetadata, $ as AsExternalProvider, aF as ConnectedSolanaWallet, ay as ContractUIOptions, aj as CrossAppAccount, at as CrossAppAccountWithMetadata, ad as Discord, am as DiscordOAuthWithMetadata, av as Email, a8 as EmailWithMetadata, aC as Farcaster, ar as FarcasterWithMetadata, ae as Github, an as GithubOAuthWithMetadata, ab as Google, ak as GoogleOAuthWithMetadata, af as LinkedIn, ap as LinkedInOAuthWithMetadata, aE as LoginMethodOrderOption, a1 as MessageTypes, a2 as MoonpayConfig, a3 as MoonpayCurrencyCode, aA as MoonpayFundingConfig, a4 as MoonpayPaymentMethod, az as NativeFundingConfig, a7 as NonEmptyArray, aD as Passkey, au as PasskeyWithMetadata, aw as Phone, a9 as PhoneWithMetadata, aB as PriceDisplayOptions, a5 as Quantity, ai as Telegram, as as TelegramWithMetadata, ah as Tiktok, ao as TiktokOAuthWithMetadata, a6 as TransactionLog, ax as TransactionUIOptions, ac as Twitter, al as TwitterOAuthWithMetadata, a0 as TypedMessage, aa as WalletWithMetadata } from './types.js';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { TurnstileProps } from '@marsidev/react-turnstile';
import EventEmitter from 'eventemitter3';
import { Store, EIP6963ProviderDetail } from 'mipd';
import { Web3Provider, TransactionResponse } from '@ethersproject/providers';
import * as _simplewebauthn_types from '@simplewebauthn/types';
import { PublicKeyCredentialRequestOptionsJSON } from '@simplewebauthn/types';
import * as _solana_wallet_adapter_base from '@solana/wallet-adapter-base';
import { SendTransactionOptions } from '@solana/wallet-adapter-base';
import * as _solana_web3_js from '@solana/web3.js';
import { Connection } from '@solana/web3.js';
import { AbstractProvider } from 'web3-core';
import { SupportedSolanaTransaction, SolanaTransactionReceipt } from './solana.js';
export { UseSolanaWalletsInterface, useSolanaWallets } from './solana.js';
import { CustomMetadataType, SmartWalletType, PrivyCoinbaseOnRampInitInput, PrivyCoinbaseOnRampInitResponse, PrivyCoinbaseOnRampStatusResponse } from '@privy-io/public-api';
import { FetchOptions } from 'ofetch';
import '@metamask/eth-sig-util';
import 'viem';
import '@privy-io/js-sdk-core';

declare const DEFAULT_SUPPORTED_CHAINS: readonly [Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain];

interface ResponseEmailAccount {
    type: 'email';
    address: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponsePhoneAccount {
    type: 'phone';
    phoneNumber: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface BaseResponseWalletAccount {
    type: 'wallet';
    address: string;
    imported: boolean;
    chain_type: 'ethereum' | 'solana';
    chain_id?: string;
    /**
     * @deprecated Use `wallet_client_type` instead.
     */
    wallet_client: 'privy' | 'unknown';
    wallet_index: number | null;
    wallet_client_type?: string;
    connector_type?: string;
    recovery_method?: 'privy' | 'user-passcode';
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseEthereumAccount extends BaseResponseWalletAccount {
    chain_type: 'ethereum';
}
interface ResponseSolanaAccount extends BaseResponseWalletAccount {
    chain_type: 'solana';
}
interface ResponseSmartWalletAccount {
    type: 'smart_wallet';
    address: string;
    smart_wallet_type: SmartWalletType;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseFarcasterAccount {
    type: 'farcaster';
    fid: number;
    owner_address: string;
    username: string | null;
    display_name: string | null;
    bio: string | null;
    profile_picture_url: string | null;
    homepage_url: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
    signer_public_key: string | null;
}
interface ResponseOAuthGoogle {
    type: 'google_oauth';
    subject: string;
    email: string;
    name: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthTwitter {
    type: 'twitter_oauth';
    subject: string;
    username: string | null;
    name: string | null;
    profile_picture_url: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthDiscord {
    type: 'discord_oauth';
    subject: string;
    username: string | null;
    email: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthGithub {
    type: 'github_oauth';
    subject: string;
    username: string | null;
    name: string | null;
    email: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthSpotify {
    type: 'spotify_oauth';
    subject: string;
    email: string | null;
    name: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthInstagram {
    type: 'instagram_oauth';
    subject: string;
    username: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthTiktok {
    type: 'tiktok_oauth';
    subject: string;
    username: string | null;
    name: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthLinkedIn {
    type: 'linkedin_oauth';
    subject: string;
    name: string | null;
    email: string | null;
    vanity_name: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthApple {
    type: 'apple_oauth';
    subject: string;
    email: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseCustomJwtAccount {
    type: 'custom_auth';
    custom_user_id: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponsePasskeyAccount {
    type: 'passkey';
    credential_id: string;
    enrolled_in_mfa: boolean;
    authenticator_name?: string;
    created_with_device?: string;
    created_with_os?: string;
    created_with_browser?: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseTelegramAccount {
    type: 'telegram';
    telegram_user_id: string;
    first_name: string | null;
    last_name: string | null;
    username: string | null;
    photo_url: string | null;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseCrossAppAccount {
    type: 'cross_app';
    subject: string;
    embedded_wallets: {
        address: string;
    }[];
    smart_wallets: {
        address: string;
    }[];
    provider_app_id: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
type LinkedAccountsResponseType = Array<ResponseEmailAccount | ResponsePhoneAccount | ResponseEthereumAccount | ResponseSmartWalletAccount | ResponseSolanaAccount | ResponseOAuthGoogle | ResponseOAuthTwitter | ResponseOAuthDiscord | ResponseOAuthGithub | ResponseOAuthSpotify | ResponseOAuthInstagram | ResponseOAuthTiktok | ResponseOAuthLinkedIn | ResponseOAuthApple | ResponseCustomJwtAccount | ResponseFarcasterAccount | ResponsePasskeyAccount | ResponseTelegramAccount | ResponseCrossAppAccount>;
interface ResponseSmsMfaMethod {
    type: 'sms';
    verified_at: number;
}
type LinkedMfaMethodsResponseType = Array<ResponseSmsMfaMethod>;
interface GetCurrentUserResponse {
    id: string;
    is_guest: boolean;
    created_at: number;
    linked_accounts: LinkedAccountsResponseType;
    mfa_methods: LinkedMfaMethodsResponseType;
    has_accepted_terms: boolean;
    oauth_tokens?: {
        provider: string;
        access_token: string;
        access_token_expires_in_seconds?: number;
        refresh_token?: string;
        refresh_token_expires_in_seconds?: number;
        scopes?: string[];
    };
    custom_metadata?: CustomMetadataType;
}

interface DefaultsType {
    baseURL: string;
    timeout: number;
}
/**
 * A raw http handler for making requests to the Privy API. It requires a Session
 * object, which is used for fetching and including any tokens that are required
 * for requests.
 *
 * Should not be used for external requests, as we attach a good deal of metadata to requests.
 */
declare class Http {
    fallbackApiUrl: string;
    private appId;
    private appClientId?;
    private client;
    private defaults;
    private sdkVersion;
    private baseFetch;
    private clientAnalyticsId;
    constructor({ appId, appClientId, client, defaults, }: {
        appId: string;
        appClientId?: string;
        client: PrivyClient;
        defaults: DefaultsType;
    });
    get<T = any>(path: string, config?: FetchOptions<'json'>): Promise<T>;
    post<T = any, D = any>(path: string, data?: D, config?: FetchOptions<'json'>): Promise<T>;
    delete<T = any>(path: string, config?: FetchOptions<'json'>): Promise<T>;
}

/**
 * Valid /session and <>/authenticate calls will respond with a token
 * as well as a valid user object for streamlining.
 */
interface ValidSessionResponse {
    user: GetCurrentUserResponse;
    token: string;
    refresh_token: string | null;
    identity_token?: string;
    is_new_user?: boolean;
    session_update_action?: 'set' | 'ignore' | 'clear';
    oauth_tokens?: {
        provider: string;
        access_token: string;
        access_token_expires_in_seconds?: number;
        refresh_token?: string;
        refresh_token_expires_in_seconds?: number;
        scopes?: string[];
    };
}

type AuthMeta = {
    [key: string]: any;
};
/**
 * An auth flow is an encapsulation of the business logic required for a given
 * authentication process. It requires at least one definitive `authenticate`
 * method that does the final token handshaking with the API, but may also
 * include any number of methods/API calls necessary to set up the state (e.g.
 * sending an email before being able to do a passwordless code login)
 */
interface AuthFlow {
    api?: Http;
    /**
     * Any meta information necessary for the auth flow, that may also need to be
     * shared out to things like frontend components for displaying state of the
     * auth flow
     */
    meta: AuthMeta;
    /**
     * Handles the API authentication call(s) to log users in.
     * Any preconditions must be addressed prior to calling
     */
    authenticate(): Promise<ValidSessionResponse>;
    /**
     * Handles the API link call(s) to link new user accounts.
     * Requires user to already be logged in when called.
     * Any preconditions must be addressed prior to calling
     */
    link(): Promise<GetCurrentUserResponse>;
}

declare abstract class EthereumWalletConnector extends WalletConnector {
    wallets: BaseConnectedEthereumWallet[];
    chains: Chain[];
    defaultChain: Chain;
    rpcConfig: RpcConfig;
    rpcTimeoutDuration: number;
    chainType: "ethereum";
    abstract proxyProvider: PrivyProxyProvider | Embedded1193Provider;
    constructor(walletClientType: WalletClientType, chains: Chain[], defaultChain: Chain, rpcConfig: RpcConfig);
    /**
     * Builds a connected wallet object to be exposed to the developer. This object
     * contains the address, chainId, and a few helper methods.
     *
     * Provider methods share the PrivyProxyProvider instance. This means that multiple
     * wallets may share the same provider if one wallet was disconnected and another
     * wallet was connected.
     *
     * A wallet is considered connected if it is present in the wallets array and is
     * in a connected state.
     */
    buildConnectedWallet(address: string, chainId: string, meta: ConnectedWalletMetadata, imported: boolean): BaseConnectedEthereumWallet;
    /**
     * Sync all accounts available via the provider if the wallet is connected.
     *
     * @param prefetchedAccounts - pass in an accounts array from eth_accounts if already fetched to avoid a repeated call
     */
    syncAccounts(prefetchedAccounts?: string[]): Promise<void>;
    /**
     * Get the most recently connected wallet.
     */
    getConnectedWallet(): Promise<BaseConnectedEthereumWallet | null>;
    /**
     * As a proxy for "connected", we call eth_accounts and consider the client
     * connected if at least one account is returned.
     */
    isConnected(): Promise<boolean>;
    /**
     * Perform personal_sign with the user's wallet.
     *
     * @param {string} message The message to sign.
     * @returns {string} The resulting signature.
     */
    sign(message: string): Promise<string>;
    protected onAccountsChanged: (accounts: string[]) => void;
    protected onChainChanged: (chainId: string) => void;
    protected onDisconnect: () => void;
    protected onConnect: () => void;
    subscribeListeners(): void;
    unsubscribeListeners(): void;
}

declare class EmbeddedWalletConnector extends EthereumWalletConnector {
    connectorType: ConnectorType;
    walletIndex: number;
    proxyProvider: Embedded1193Provider;
    constructor({ provider, chains, defaultChain, rpcConfig, imported, walletIndex, }: {
        provider: Embedded1193Provider;
        chains: Chain[];
        defaultChain: Chain;
        rpcConfig: RpcConfig;
        imported: boolean;
        walletIndex: number;
    });
    initialize(): Promise<void>;
    connect(options: {
        chainId?: number;
    }): Promise<BaseConnectedEthereumWallet | null>;
    get walletBranding(): {
        name: string;
        icon: ({ ...props }: React.SVGProps<SVGSVGElement>) => react_jsx_runtime.JSX.Element;
        id: string;
    };
    disconnect(): void;
    promptConnection(): Promise<void>;
}

interface ConnectorManagerEvents {
    walletsUpdated(): void;
    connectorInitialized(): void;
}
declare class ConnectorManager extends EventEmitter<ConnectorManagerEvents> {
    walletConnectors: WalletConnector[];
    initialized: boolean;
    private storedConnections;
    private activeWallet?;
    private privyAppId;
    private privyAppLogo?;
    private walletConnectCloudProjectId;
    private rpcConfig;
    private chains;
    private defaultChain;
    private store;
    private walletList;
    private shouldEnforceDefaultChainOnConnect;
    private privyAppName;
    private externalWalletConfig;
    constructor(privyAppId: string, walletConnectCloudProjectId: string, rpcConfig: RpcConfig, chains: Chain[], defaultChain: Chain, store: Store, walletList: WalletListEntry[], shouldEnforceDefaultChainOnConnect: boolean, externalWalletConfig: Required<ExternalWalletsConfig>, privyAppName: string, privyAppLogo?: string);
    /**
     * The core wallets array that is exposed to developers. It builds
     * the wallets away with the following logic:
     *
     * 1. Flatten all wallets from all connectors
     * 2. Sorted by connectedAt
     * 3. Active wallet is moved to front of array (if it exists)
     */
    get wallets(): BaseConnectedWallet[];
    /**
     * Helper function to find a wallet connector by connector type and wallet client type.
     */
    findWalletConnector(connectorType: ConnectorType, walletClientType: string): EthereumWalletConnector | null;
    /**
     * Helper function to find a solana wallet connector by connector type and wallet client type.
     */
    findSolanaWalletConnector(connectorType: ConnectorType, walletClientType: string): SolanaWalletConnector | null;
    /**
     * Helper function to find all embedded HD wallet connectors with `connectorType: 'embedded'`.
     * Does not include embedded imported wallet connectors, which have `connectorType: 'embedded_imported'`.
     */
    findEmbeddedWalletConnectors(): EmbeddedWalletConnector[];
    /**
     * Creates a new wallet connector for the given connector type and wallet client type.
     * If a connector already exists, it will be returned instead.
     */
    createEthereumWalletConnector(connectorType: ConnectorType, walletClientType: string, providers?: {
        eip6963InjectedProvider?: EIP6963ProviderDetail;
        legacyInjectedProvider?: any;
    }): Promise<EthereumWalletConnector | null>;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with wallets directly (wallets[0].getEthereumProvider()).
     *
     * Build an Ethereum provider for the most recently connected wallet.
     */
    getEthereumProvider: () => EIP1193Provider;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with `wallets` directly.
     *
     * Performing personal_sign with the most recently connected wallet.
     * If there is not a wallet connected, return null. Only supports signing with Ethereum
     * wallets.
     */
    activeWalletSign(message: string): Promise<string | null>;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with `wallets` directly.
     */
    setActiveWallet(address: string): void;
}

/**
 * This should not be directly used by developers at the moment,
 * so we doc-ignore it.
 * @ignore
 *
 */
declare class PrivyClient {
    #private;
    private appId;
    private appClientId?;
    private session;
    private timeout;
    api: Http;
    clientAnalyticsId: string | null;
    useServerCookies: boolean;
    apiUrl: string;
    fallbackApiUrl: string;
    authFlow?: AuthFlow;
    connectors?: ConnectorManager;
    onStoreToken?: ((token: string | null) => void) | undefined;
    onDeleteToken?: (() => void) | undefined;
    /**
     * Creates a new Privy client.
     * @param options Initialization options.
     */
    constructor(options: {
        /**
         * The URL of the Privy API. Defaults to `https://auth.privy.io`.
         */
        apiUrl?: string;
        /**
         * The app id from your dashboard
         */
        appId: string;
        /**
         * The app client id from your dashboard
         */
        appClientId?: string;
        /**
         * Time in milliseconds after which to timeout requests to the API. Defaults to `10000` (10 seconds).
         */
        timeout?: number;
    });
    /**
     * ConnectorManager initialization is deferred because the input parameter may be overridden by the server
     * config. We can set this once and only once. If it is set twice, event listeners will be created
     * on the first ConnectorManager and are not re-created.
     */
    initializeConnectorManager({ walletConnectCloudProjectId, rpcConfig, chains, defaultChain, store, walletList, shouldEnforceDefaultChainOnConnect, externalWalletConfig, appName, }: {
        walletConnectCloudProjectId: string;
        rpcConfig: RpcConfig;
        chains: Chain[];
        defaultChain: Chain;
        store: Store;
        walletList: WalletListEntry[];
        shouldEnforceDefaultChainOnConnect: boolean;
        externalWalletConfig: Required<ExternalWalletsConfig>;
        appName: string;
    }): void;
    generateApi(): Http;
    /**
     * In the case of cookie-based auth, re-initialize the http client with the custom api url.
     * @param customApiUrl the custom api url to use for cookie-based authFlow
     */
    updateApiUrl(customApiUrl?: string | null): void;
    authenticate(): Promise<{
        user: User | null;
        isNewUser?: boolean;
        oAuthTokens?: OAuthTokens;
    }>;
    link(): Promise<{
        user: User | null;
        oAuthTokens: OAuthTokens | undefined;
    }>;
    storeProviderAccessToken(appId: string, providerAccessToken: string | null): void;
    getProviderAccessToken(appId: string): string | null;
    logout(): Promise<void>;
    clearProviderAcccessTokens(user: User): void;
    startAuthFlow<T extends AuthFlow>(authFlow: T): T;
    initMfaSmsVerification(): Promise<void>;
    initMfaPasskeyVerification(): Promise<{
        challenge: string;
        allowCredentials: {
            id: string;
            type: "public-key";
            transports: AuthenticatorTransport[];
        }[];
        timeout: number | undefined;
        extensions: {
            appid: string | undefined;
            credProps: boolean | undefined;
            hmacCreateSecret: boolean | undefined;
        };
        userVerification: UserVerificationRequirement;
    }>;
    acceptTerms(): Promise<User>;
    unlinkEmail(address: string): Promise<User>;
    unlinkPhone(phoneNumber: string): Promise<User>;
    unlinkEthereumWallet(address: string): Promise<User>;
    unlinkSolanaWallet(address: string): Promise<User>;
    unlinkOAuth(provider: OAuthProviderType | `privy:${string}`, subject: string): Promise<User>;
    unlinkFarcaster(fid: number): Promise<User>;
    unlinkTelegram(telegramUserId: string): Promise<User>;
    unlinkPasskey(credentialId: string): Promise<User>;
    createAnalyticsEvent({ eventName, payload, timestamp, options, }: {
        eventName: string;
        payload?: {
            [key: string]: any;
        };
        timestamp?: Date;
        options?: {
            keepAlive?: boolean;
        };
    }): Promise<void>;
    signMoonpayOnRampUrl(signRequestData: MoonpaySignRequest): Promise<MoonpaySignResponse>;
    initCoinbaseOnRamp(input: PrivyCoinbaseOnRampInitInput): Promise<PrivyCoinbaseOnRampInitResponse>;
    getCoinbaseOnRampStatus({ partnerUserId, }: {
        partnerUserId: string;
    }): Promise<PrivyCoinbaseOnRampStatusResponse>;
    /** DATA METHODS */
    /**
     * Fetches the currently authenticed user from the API or
     * returns null if the user is not authenticated.
     *
     * This will refresh the user's access token and rotate
     * the refresh token if needed.
     *
     * @returns Promise<User | null>
     */
    getAuthenticatedUser(): Promise<User | null>;
    /**
     * Grab the Privy access token for the currently logged in user. Verifies that the
     * token has a valid signature, was issued by 'privy.io', and corresponds to the
     * current app ID. If no valid token is found, this method will force a logout and return null.
     *
     * If the token is expired or expiring soon, this will attempt to
     * first refresh the access token to ensure that the token is active. You can
     * disable this behavior using `disableAutoRefresh`, although it is not
     * recommended.
     *
     * @param disableAutoRefresh not recommended - optionally disable automatic
     * token refresh when the token is
     *
     * @returns Promise<string | null>
     */
    getAccessToken(options?: {
        disableAutoRefresh?: boolean;
    }): Promise<string | null>;
    getSmartWalletsConfig(): Promise<SmartWalletConfig>;
    getServerConfig(): Promise<PrivyServerConfig>;
    getUsdTokenPrice(chain: Chain): Promise<number | undefined>;
    getUsdPriceForSol(): Promise<number | undefined>;
    requestFarcasterSignerStatus(publicKey: string): Promise<PrivyFarcasterSignerInitResponse>;
    /**
     * Get a short-lived token to start a new Privy session from the existing authenticated session.
     *
     * Rotates the access token and refresh token.
     * Raises an exception if the current session was already forked from a previous session,
     * or if the current session is not authenticated.
     *
     * @returns Promise<string>
     */
    forkSession(): Promise<string>;
    /**
     * Headless method to authenticate a smart wallet via the Sign-In with Ethereum spec.
     *
     * @returns The user object.
     */
    linkSmartWallet({ message, signature, smartWalletType, }: {
        message: string;
        signature: string;
        smartWalletType: SmartWalletType;
    }): Promise<User>;
    /**
     * Headless method to link a new wallet via the Sign-In with Ethereum spec.
     *
     * @returns The user object.
     */
    linkWithSiwe({ message, signature, chainId, walletClientType, connectorType, }: {
        message: string;
        signature: string;
        chainId: string;
        walletClientType?: string;
        connectorType?: string;
    }): Promise<User>;
    /**
     *
     */
    sendAccountTransferRequest({ nonce, account, accountType, externalWalletMetadata, telegramAuthResult, farcasterEmbeddedAddress, oAuthUserInfo, }: {
        nonce: string;
        account: string;
        accountType: LoginMethod;
        externalWalletMetadata?: SiweWalletMetadata;
        telegramAuthResult?: TelegramAuthResult;
        farcasterEmbeddedAddress?: string;
        oAuthUserInfo?: OAuthUserInfo;
    }): Promise<User>;
    /**
     * Headless method to link a new wallet via the Sign-In with Solana spec.
     *
     * @returns The user object.
     */
    linkWithSiws({ message, signature, walletClientType, connectorType, }: {
        message: string;
        signature: string;
        walletClientType?: string;
        connectorType?: string;
    }): Promise<User>;
}

declare function getAccessToken(): Promise<string | null>;
/**
 * Properties to initialize the {@link PrivyProvider}.
 */
interface PrivyProviderProps {
    /** Your Privy App ID, which can be retrieved from the Privy dashboard. */
    appId: string;
    /** Your Privy App Client ID, which can be retrieved from the Privy dashboard. */
    clientId?: string;
    /**
     * @deprecated. Use the `onSuccess` callback registered via the `useLogin` hook instead.
     *
     * An optional callback that will execute once a `login` call successfully completes.
     *
     * Within this callback, you can access:
     * - the `user` object corresponding to the authenticated user
     * - an `isNewUser` boolean flag indicating if this is the user's first time logging in to your app
     *
     */
    onSuccess?: (user: User, isNewUser: boolean) => void;
    /**
     * @deprecated use `config.embeddedWallets.createOnLogin` instead
     */
    createPrivyWalletOnLogin?: boolean;
    /**
     * Client configuration options.
     * Values here will override their server-configuration counterparts.
     */
    config?: PrivyClientConfig;
    /**
     * @ignore
     * @class
     */
    children: react__default.ReactNode;
}
/**
 * Passes the Privy authentication context to your React components.
 *
 * This should wrap any components that will to use the Privy SDK via the {@link usePrivy} hook. As an example:
 *
 * ```typescript
 * // At your application root (e.g. `_app.tsx` in NextJS):
 * import {PrivyProvider} from '@privy-io/react-auth';
 *
 * <PrivyProvider appId="APP_ID_FROM_DASHBOARD" onSuccess={() => console.log('Success!')}>
 *   <Component {...pageProps} />
 * </PrivyProvider>
 * ```
 *
 */
declare const PrivyProvider: ({ config, ...props }: PrivyProviderProps) => JSX.Element;

type CaptchaProps = Partial<Pick<TurnstileProps, 'onUnsupported' | 'onError' | 'onSuccess' | 'onExpire' | 'onSubmit'>> & {
    delayedExecution?: boolean;
};
/**
 * Used to render an invisible captcha alongside important forms
 *
 * Notes:
 * - **Only for internal use, or use with headless SDK** _(the Privy modal handles captchas internally with this component)_
 * - Only one `<Captcha />` should be rendered at a time, since it injects/removes a global script
 * - the state of the captcha workflow can be accessed using `useCaptcha`
 * - wrapper around [marsidev/react-turnstile](https://github.com/marsidev/react-turnstile), _accepts same [props](https://docs.page/marsidev/react-turnstile/props)_
 */
declare const Captcha: (props: CaptchaProps) => react_jsx_runtime.JSX.Element | null;

/**
 * Allows you to manage the user's current authentication state and access their linked accounts.
 * You can access the fields and methods documented here via the {@link usePrivy} hook.
 */
interface PrivyInterface {
    /**
     * Check whether the `PrivyProvider` is ready to be used. You should wait for this to
     * be true before using values such as `authenticated` and `user`.
     */
    ready: boolean;
    /**
     * True if the user is authenticated, false otherwise.
     *
     * You should always check that `ready` is true before using this value. Otherwise,
     * the value may outdated while the Privy client fetches fresh tokens.
     *
     */
    authenticated: boolean;
    /**
     * The user object, or null if the user is not authenticated.
     */
    user: User | null;
    /**
     * Opens the Privy modal and prompts the user to connect a wallet.
     * @param options.suggestedAddress {string} (optional) wallet address that you wish to prompt the user to explicitly connect, if included
     */
    connectWallet: (options?: ConnectWalletModalOptions | MouseEvent<any, any>) => void;
    /**
     * Opens the Privy login modal and prompts the user to login.
     * @param options.loginMethods {LoginMethod[]} custom login methods to display in the login modal. This will overwrite the value provider to the client config.
     * @param options.prefill {PrefillLoginOptions} prefill the login modal with the provided email or phone number.
     */
    login: (options?: LoginModalOptions | MouseEvent<any, any>) => void;
    /**
     * Opens the Privy login modal and prompts the user to login or connect a wallet.
     */
    connectOrCreateWallet: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link an email.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkEmail: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link a phone number.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkPhone: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link a wallet.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkWallet: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link a Farcaster account.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkFarcaster: () => void;
    /**
     * For users who are authenticated, prompts the user to link a Google OAuth account.
     * This will directly initiate the OAuth flow for Google.
     */
    linkGoogle: () => void;
    /**
     * For users who are authenticated, prompts the user to link a Twitter OAuth account
     * This will directly initiate the OAuth flow for Twitter.
     */
    linkTwitter: () => void;
    /**
     * For users who are authenticated, prompts the user to link Discord OAuth account
     * This will directly initiate the OAuth flow for Discord.
     */
    linkDiscord: () => void;
    /**
     * For users who are authenticated, prompts the user to link Github OAuth account
     * This will directly initiate the OAuth flow for Github.
     */
    linkGithub: () => void;
    /**
     * For users who are authenticated, prompts the user to link Spotify OAuth account
     * This will directly initiate the OAuth flow for Spotify.
     */
    linkSpotify: () => void;
    /**
     * For users who are authenticated, prompts the user to link Instagram OAuth account
     * This will directly initiate the OAuth flow for Instagram.
     */
    linkInstagram: () => void;
    /**
     * For users who are authenticated, prompts the user to link Tiktok OAuth account
     * This will directly initiate the OAuth flow for Tiktok.
     */
    linkTiktok: () => void;
    /**
     * For users who are authenticated, prompts the user to link LinkedIn OAuth account
     * This will directly initiate the OAuth flow for LinkedIn.
     */
    linkLinkedIn: () => void;
    /**
     * For users who are authenticated, prompts the user to link Apple OAuth account
     * This will directly initiate the OAuth flow for Apple.
     */
    linkApple: () => void;
    /**
     * For users who are authenticated, prompts the user to link a Passkey account
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkPasskey: () => void;
    /**
     * @experimental
     * For users who are authenticated, prompts the user to link a Telegram account
     * This will directly initiate the auth flow for Telegram.
     */
    linkTelegram: () => void;
    /**
     * For users who are authenticated and have already linked an email address, prompts the user to update their email address.
     * This will open the Privy Modal which will guide the user through this action.
     *
     */
    updateEmail: () => void;
    /**
     * For users who are authenticated and have already linked a phone number, prompts the user to update their phone number.
     * This will open the Privy Modal which will guide the user through this action.
     */
    updatePhone: () => void;
    /**
     * Log the current user out and clears their authentication state. `authenticated` will become false, `user` will become null, and the Privy Auth tokens will be deleted from the browser's local storage.
     *
     * You may await this call to take an action once logout is complete (e.g. redirecting to a specific page).
     */
    logout: () => Promise<void>;
    /**
     * Get the Privy access token ([JWT](https://jwt.io/)) for an authenticated user. Returns null for an unauthenticated user.
     *
     * You may use this token to authorize requests sent from your frontend, and can validate it in your backend against your app's Privy verification key.
     *
     * This will automatically attempt to refresh the session if the token is expired or about to expire.
     *
     * @returns Promise for the user's access token as a string if they are authenticated, null if they are unauthenticated.
     */
    getAccessToken: () => Promise<string | null>;
    /**
     * @deprecated **Deprecated**: This method will be deprecated and should be replaced by calling `getEthereumProvider`
     * directly on the `ConnectedWallet` objects returned by the `useWallets` hook, e.g.
     *
     * ```tsx
     * const {wallets} = useWallets();
     * const provider = await wallets[0].getEthereumProvider();
     * ```
     *
     *
     * Gets an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193)-compatible provider from the user's wallet, if the user has connected one.
     *
     * You may then use the Ethereum Javascript API syntax to send JSON-RPC requests to the user's wallet.
     */
    getEthereumProvider: () => EIP1193Provider;
    /**
     * @deprecated **Deprecated**: This method will be deprecated and should be replaced by calling `getEthersProvider`
     * directly on the `ConnectedWallet` objects returned by the `useWallets` hook, e.g.
     *
     * ```tsx
     * const {wallets} = useWallets();
     * const provider = await wallets[0].getEthersProvider();
     * ```
     *
     * Get an [ethers.js](https://docs.ethers.io/v5/)-compatible provider from the user's wallet, if the user has connected one.
     *
     */
    getEthersProvider: () => Web3Provider;
    /**
     * @deprecated **Deprecated**: This feature will be deprecated and should be replaced by calling `getWeb3jsProvider`
     * directly on the `ConnectedWallet` objects returned by the `useWallets` hook, e.g.
     *
     * ```tsx
     * const {wallets} = useWallets();
     * const provider = await wallets[0].getWeb3jsProvider();
     * ```
     *
     * Get a [web3.js](https://web3js.readthedocs.io/en/v1.8.0/)-compatible provider from the user's wallet, if the user has connected one.
     */
    getWeb3jsProvider: () => AbstractProvider;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by the
     * `useWallets` hook.
     *
     * Get the ConnectorManager object
     * This shouldn't need to be used directly unless creating a plugin, like a WAGMI plugin
     */
    walletConnectors: ConnectorManager | null;
    /**
     * Unlink an email account from a user, by passing the email address. Note that you can only unlink an email account if the user has at least one other account.
     *
     * @param address {string} email address to be unlinked
     * @returns Promise for the {@link User} object after the provided email has been unlinked
     */
    unlinkEmail: (address: string) => Promise<User>;
    /**
     * Unlink a phone account from a user, by passing the phone number. Note that you can only unlink a phone account if the user has at least one other account.
     *
     * @param phoneNumber {string} phone number to be unlinked
     * @returns Promise for the {@link User} object after the provided phone number has been unlinked
     */
    unlinkPhone: (phoneNumber: string) => Promise<User>;
    /**
     * Unlink a wallet account from a user, by passing the public address. Note that you can only unlink a wallet account if the user has at least one other account.
     * If the unlinked wallet was the active one, and more wallets are linked to the user, then we attempt to make the most recently linked wallet active.
     *
     * @param address {string} wallet address to be unlinked
     * @returns Promise for the {@link User} object after the provided wallet has been unlinked
     */
    unlinkWallet: (address: string) => Promise<User>;
    /**
     * Unlink a Google social account from a user, by passing the google subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} google account's subject ID
     * @returns Promise for the {@link User} object after the provided Google account has been unlinked
     */
    unlinkGoogle: (subject: string) => Promise<User>;
    /**
     * Unlink a Twitter social account from a user, by passing the twitter subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} twitter account's subject ID
     * @returns Promise for the {@link User} object after the provided Twitter account has been unlinked
     */
    unlinkTwitter: (subject: string) => Promise<User>;
    /**
     * Unlink a Discord social account from a user, by passing the discord subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} discord account's subject ID
     * @returns Promise for the {@link User} object after the provided Discord account has been unlinked
     */
    unlinkDiscord: (subject: string) => Promise<User>;
    /**
     * Unlink a Github social account from a user, by passing the github subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} github account's subject ID
     * @returns Promise for the {@link User} object after the provided Github account has been unlinked
     */
    unlinkGithub: (subject: string) => Promise<User>;
    /**
     * Unlink a Spotify social account from a user, by passing the spotify subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} spotify account's subject ID
     * @returns Promise for the {@link User} object after the provided Spotify account has been unlinked
     */
    unlinkSpotify: (subject: string) => Promise<User>;
    /**
     * Unlink a Instagram social account from a user, by passing the instagram subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} instagram account's subject ID
     * @returns Promise for the {@link User} object after the provided Instagram account has been unlinked
     */
    unlinkInstagram: (subject: string) => Promise<User>;
    /**
     * Unlink a Tiktok social account from a user, by passing the tiktok subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} tiktok account's subject ID
     * @returns Promise for the {@link User} object after the provided Tiktok account has been unlinked
     */
    unlinkTiktok: (subject: string) => Promise<User>;
    /**
     * Unlink a LinkedIn social account from a user, by passing the linkedin subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} linkedin account's subject ID
     * @returns Promise for the {@link User} object after the provided LinkedIn account has been unlinked
     */
    unlinkLinkedIn: (subject: string) => Promise<User>;
    /**
     * Unlink a Apple social account from a user, by passing the apple subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} apple account's subject ID
     * @returns Promise for the {@link User} object after the provided Apple account has been unlinked
     */
    unlinkApple: (subject: string) => Promise<User>;
    /**
     * Unlink a cross-app account from a user, by passing the apple subject ID. Note that you can only unlink this account if the user has at least one other account.
     *
     * @param subject {string} apple account's subject ID
     * @returns Promise for the {@link User} object after the provided cross-app account has been unlinked
     */
    unlinkCrossAppAccount: ({ subject }: {
        subject: string;
    }) => Promise<User>;
    /**
     * Unlink a Farcaster account from a user, by passing the FID. Note that you can only unlink a phone account if the user has at least one other account.
     *
     * @param fid {number} Farcaster ID
     * @returns Promise for the {@link User} object after the provided Farcaster account has been unlinked
     */
    unlinkFarcaster: (fid: number) => Promise<User>;
    /**
     * @experimental
     * Unlink a Telegram account from a user, by passing the Telegram subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param telegramUserId {string} Telegram user ID of the linked account
     * @returns Promise for the {@link User} object after the provided Telegram account has been unlinked
     */
    unlinkTelegram: (telegramUserId: string) => Promise<User>;
    /**
     * Unlink a Passkey account from a user, by passing the credential ID. Note that you can only unlink a passkey account if the user has at least one other account.
     *
     * @param credentialId {string} Passkey Credential ID
     * @returns Promise for the {@link User} object after the provided passkey account has been unlinked
     */
    unlinkPasskey: (credentialId: string) => Promise<User>;
    /**
     * @deprecated **Deprecated**: This feature will be removed and behaves the same as connectWallet(). Instead, please
     * interact with the wallets array directly.
     *
     * Note that when you connect a new wallet, it becomes first in the wallets array.
     */
    setActiveWallet: (address: string) => Promise<void>;
    /**
     * @experimental **Experimental**: This feature is {@link https://docs.privy.io/guide/guides/experimental-features subject to change at any time}.
     *
     * Get a short-lived, one-time-use token to start a new Privy session from the existing authenticated session. Raises an exception if the current session was already forked from a previous session.
     */
    forkSession: () => Promise<string>;
    /**
     * Creates an embedded wallet for the current user.
     *
     * This method will error if the user already has an embedded wallet or if they
     * exit in the middle of the flow.
     *
     * If the `config.embeddedWallets.requireUserOwnedRecoveryOnCreate` property is set to true,
     * this will prompt the user to complete a recovery flow to secure the recovery
     * share of their embedded wallet.
     *
     * Otherwise (the default), Privy will secure the recovery share, and the embedded wallet
     * will be created without showing any UIs to the user.
     *
     * @returns Promise for the {@link Wallet} object for the newly created embedded wallet
     */
    createWallet: (options?: CreateWalletOptions | MouseEvent<any, any>) => Promise<Wallet>;
    /**
     * @deprecated. Use `setWalletRecovery` instead.
     *
     * Set (or reset) a password on a wallet.
     *
     * This method will error if the user does not have an embedded wallet or if the user exits in the middle of the flow.
     *
     * @returns Promise for the {@link Wallet} object for the updated embedded wallet
     */
    setWalletPassword: () => Promise<Wallet>;
    /**
     * Prompt the user to enable wallet recovery. Current recovery options include password, Google Drive, and iCloud.
     *
     * This method will error if the user does not have an embedded wallet, if the user's
     * embedded wallet already has a cloud-based recovery set, or if the user exits in the middle of the flow.
     *
     * @returns Promise for the {@link Wallet} object for the updated embedded wallet
     */
    setWalletRecovery: (o?: SetWalletRecoveryOptions) => Promise<Wallet>;
    /**
     * Prompts a user to sign a message using their embedded wallet using EIP-191's `personal_sign`
     * method (0x45).
     *
     * This method will error if the user is not authenticated or does not have an embedded wallet.
     *
     * If the `config.embeddedWallets.noPromptOnSignature` property is set to true, the signature will
     * be computed without prompting the user. Otherwise (the default), Privy will show the user a modal
     * to prompt them for a signature. This can be customized via the {@link SignMessageModalUIOptions}.
     *
     * @param message {string} message to be signed
     * @param uiOptions {@link SignMessageModalUIOptions} (optional) UI options to customize the signature prompt modal
     * @param address {optional} address for the embedded wallet signing the message. You should ONLY set this parameter if using imported
     * embedded wallets or multiple HD embedded wallets for the same user. Defaults to the user's embedded wallet at HD index 0.
     * @returns Promise for the signature as a string
     */
    signMessage: (message: string, uiOptions?: SignMessageModalUIOptions, address?: string) => Promise<string>;
    /**
     * Prompts a user to sign a message using their embedded wallet using EIP-712's `eth_signTypedData_v4`.
     *
     * This method will error if the user is not authenticated or does not have an embedded wallet.
     *
     * @param message {SignTypedDataParams} typed data payload to be signed
     * @param uiOptions {@link SignMessageModalUIOptions} (optional) UI options to customize the signature prompt modal
     * @param address {optional} address for the embedded wallet signing the message. You should ONLY set this parameter if using imported
     * embedded wallets or multiple HD embedded wallets for the same user. Defaults to the user's embedded wallet at HD index 0.
     * @returns Promise for the signature as a string
     */
    signTypedData: (typedData: SignTypedDataParams, uiOptions?: SignMessageModalUIOptions, address?: string) => Promise<string>;
    /**
     * Function to control the visibility of the enrollment modal.
     *
     * @param show {boolean} controls the visibility of the enrollment modal.
     * @returns Promise for opening the enrollment modal.
     */
    enrollInMfa: (show?: boolean) => void;
    /**
     * Initiate the enrollment flow for MFA for the current user.
     *
     * @param mfaMethod {@link MfaMethod} The MFA method to enroll for the current user.
     * @param meta {@link {phoneNumber: string}} The meta data needed to complete the MFA flow.
     * @returns Promise for enrolling the current user with the chosen MFA method.
     */
    initEnrollmentWithSms: (meta: {
        phoneNumber: string;
    }) => Promise<void>;
    /**
     * Initiate the enrollment flow for TOTP MFA for the current user.
     *
     * @returns {@link {secret: string; authUrl: string}} The TOTP Auth Url is used to encode
     * into a QR Code for the user to scane.
     */
    initEnrollmentWithTotp: () => Promise<{
        secret: string;
        authUrl: string;
    }>;
    /**
     * Initiate the enrollment flow for Passkey MFA for the current user.
     *
     * @returns {@link void} The TOTP Auth Url is used to encode
     * into a QR Code for the user to scane.
     */
    initEnrollmentWithPasskey: () => Promise<void>;
    /**
     * Submit the MFA code to complete SMS enrollment process.
     *
     * @param meta {@link {phoneNumber: string; mfaCode: string}} The MFA code and phone number to submit.
     * @returns Promise for the MFA code submission.
     */
    submitEnrollmentWithSms: (meta: {
        phoneNumber: string;
        mfaCode: string;
    }) => Promise<void>;
    /**
     * Submit the MFA code to complete TOTP enrollment process.
     *
     * @param meta {@link {mfaCode: string}} The MFA code.
     * @returns Promise for the MFA code submission.
     */
    submitEnrollmentWithTotp: (meta: {
        mfaCode: string;
    }) => Promise<void>;
    /**
     * Submit the passkey to complete the enrollment process.
     *
     * @param meta {@link {credentialIds: string[]}} The passkey credentialIds to enroll in MFA.
     * @returns Promise for the MFA code submission.
     */
    submitEnrollmentWithPasskey: (meta: {
        credentialIds: string[];
    }) => Promise<void>;
    /**
     * Triggers the MFA verification flow if the user has an MFA method enrolled.
     *
     * @returns Promise for triggering the MFA verification flow.
     */
    promptMfa: () => Promise<void>;
    /**
     * Initiate the MFA flow for the current user.
     *
     * @param mfaMethod {@link MfaMethod} The available MFA method to trigger for the current user.
     * @returns Promise for sending the MFA code to the user's device.
     */
    init: (mfaMethod: MfaMethod) => Promise<void | PublicKeyCredentialRequestOptionsJSON>;
    /**
     * Submit the MFA code for the current user. This will attempt to complete the MFA flow.
     *
     * This will reject if:
     *   - The verification attempt failed
     *   - The max number of verification attempts has been reached
     *   - The MFA attempt timed out
     *
     * These errors can be caught and handled accordingly using the error helpers `errorIndicatesMfaVerificationFailed`,
     * `errorIndicatesMaxMfaRetries`, `errorIndicatesMfaTimeout` exported from 'react-auth'.
     *
     * @param method {@link MfaMethod} The MFA method to be used.
     * @param mfaCode {string} The MFA code to submit.
     * @returns Promise for the MFA code submission.
     */
    submit: (mfaMethod: MfaMethod, mfaCode: string | PublicKeyCredentialRequestOptionsJSON) => Promise<void>;
    /**
     * Cancel the MFA flow for the current user. If there is no pending MFA verification,
     * this function is a no-op.
     *
     * Call this method instead of `submit` when a user has been prompted for
     * MFA but decides to exit the flow.
     *
     * @returns void.
     */
    cancel: () => void;
    /**
     * Remove the MFA method for the current user.
     *
     * @param method {@link MfaMethod} The MFA method to remove for the current user.
     * @returns Promise for removing the MFA method for the current user.
     */
    unenroll: (method: MfaMethod) => Promise<void>;
    /**
     * Prompts a user to send a transaction using their embedded wallet.
     *
     * This method will error if the user is not authenticated or does not have an ethereum embedded wallet.
     *
     * If no `chainId` is specified as part of the {@link UnsignedTransactionRequest}, Privy will default
     * to the embedded wallet's current chain ID.
     *
     * If the `config.embeddedWallets.noPromptOnSignature` property is set to true, the wallet will
     * attempt to send the transaction without prompting the user. Otherwise (the default), Privy
     * will show the user a modal to have them confirm the transaction. This can be customized via
     * the {@link SendTransactionModalUIOptions}.
     *
     * @param data {@link UnsignedTransactionRequest} transaction to be sent
     * @param uiOptions {@link SendTransactionModalUIOptions} (optional) UI options to customize the transaction request modal
     * @param fundWalletConfig {@link FundWalletConfig} (optional) Funding configuration to specify chain and funding amount (if enabled), in the case of insufficient funds
     * @param address {optional} address for the embedded wallet signing the message. You should ONLY set this parameter if using imported
     * embedded wallets or multiple HD embedded wallets for the same user. Defaults to the user's embedded wallet at HD index 0.
     * @returns Promise for the transaction's {@link TransactionReceipt}
     */
    sendTransaction: (data: UnsignedTransactionRequest, uiOptions?: SendTransactionModalUIOptions, fundWalletConfig?: FundWalletConfig, address?: string) => Promise<TransactionReceipt>;
    /**
     * Prompts a user to send a transaction using their embedded wallet.
     *
     * This method will error if the user is not authenticated or does not have a solana embedded wallet.
     *
     * If the `config.embeddedWallets.noPromptOnSignature` property is set to true, the wallet will attempt to send
     * the transaction without prompting the user. Otherwise (the default), Privy will show the user a modal to have
     * them confirm the transaction. This can be customized via the {@link SendTransactionModalUIOptions}.
     *
     * @param transaction {SupportedSolanaTransaction} transaction to be sent
     * @param connection {Connection} connection to the Solana network
     * @param uiOptions {@link SendTransactionModalUIOptions} (optional) UI options to customize the transaction request modal
     * @param transactionOptions {@link SendTransactionOptions} (optional) Transaction options to customize the transaction request
     */
    sendSolanaTransaction: (transaction: SupportedSolanaTransaction, connection: Connection, uiOptions?: SendTransactionModalUIOptions, transactionOptions?: SendTransactionOptions) => Promise<SolanaTransactionReceipt>;
    /**
     * Shows the user a Privy modal, from which they can copy their embedded wallet's private
     * key or seed phrase for easy export to another wallet client (e.g. MetaMask). The private key is loaded
     * on an iframe running on a separate domain from your app, meaning your app cannot access it.
     *
     * This method will error if the user is not authenticated or does not have an embedded wallet.
     * @param options {@link {address: string}} (optional) wallet address to export the private key for
     * @returns Promise that resolves once the user exits the modal
     */
    exportWallet: (options?: {
        address: string;
    } | MouseEvent<any, any>) => Promise<void>;
    /**
     * Check whether the Privy Modal is visible.
     */
    isModalOpen: boolean;
    /**
     * The available mfa methods of this App
     */
    mfaMethods: MfaMethod[];
}
/**
 * [React Hook](https://reactjs.org/docs/hooks-intro.html) that allows you to manage the user's current authentication state and access their linked accounts.
 *
 * You should use this hook to access the Privy SDK from within your React components and custom hooks.
 */
declare const usePrivy: () => PrivyInterface;

/**
 * Allows you to manage the user's currently connected wallets.
 * You can access the fields and methods documented here via the {@link useWallets} hook.
 */
interface UseWalletsInterface {
    /**
     * The user's connected wallets.
     */
    wallets: ConnectedWallet[];
    ready: boolean;
}
declare function useWallets(): UseWalletsInterface;

/**
 * Use this hook to execute the MFA flow with Privy.
 *
 * @returns promptMfa - prompts the user to complete MFA verification
 * @returns init - starts the MFA verification flow
 * @returns submit - completes the MFA verification flow
 * @returns cancel - cancels the MFA verification flow
 * @returns mfaMethods - list of all available mfa methods
 *
 * @example
 * // MFA flow
 *
 * const MFAModal = ({ mfaMethods, isOpen, setIsOpen }: Props) => {
 *   const {init, submit, cancel} = useMfa();
 *   const [selectedMethod, setSelectedMethod] = useState(null)
 *   const [mfaCode, setMfaCode] = useState('')
 *
 *   const handleClose = () => {
 *     cancel();
 *     setIsOpen(false);
 *   };
 *
 *   return (
 *     <Modal isOpen={isOpen} onClose={handleClose}>
 *       // Capture the user's MFA code
 *       {selectedMethod && (
 *         <button
 *           onClick={async () => {
 *             await submit(selectedMethod, mfsCode)
 *             setSelectedMethod(null)
 *             setIsOpen(false)
 *           }}
 *         />
 *       )}
 *       {mfaMethods.map(method => (
 *         <button
 *           onClick={async () => {
 *             await init(method);
 *             setSelectedMethod(method)
 *           }}
 *         >
 *           Choose {method} for MFA
 *         </button>
 *       ))}
 *     </Modal>
 *   )
 * };
 *
 * @example
 * // Error handling
 *
 * import {
 *   errorIndicatesMfaVerificationFailed,
 *   errorIndicatesMfaTimeout,
 *   errorIndicatesMfaMaxAttempts
 * } from '@privy-io/react-auth';
 * const {submit} = useMfa();
 * const [errorState, setErrorState] = useState<string | null>(null);
 *
 * <button
 *   onClick={async () => {
 *     try {
 *       submit('sms', '<user-mfa-code>');
 *     }
 *     catch (e) {
 *       if (errorIndicatesMfaVerificationFailed(e)) {
 *         setErrorState('Verification failed, resubmit.')
 *       }
 *       else if (errorIndicatesMfaMaxAttempts(e)) {
 *         setErrorState('Max attempts reached, re-initialize MFA.')
 *       }
 *       else if (errorIndicatesMfaTimeout(e)) {
 *         setErrorState('Timeout reached, re-initialize MFA.')
 *       }
 *   }}
 * >
 *   {errorState ?? 'Verify SMS MFA Code'}
 * </button>
 *
 */
declare function useMfa(): {
    promptMfa: () => Promise<void>;
    init: (mfaMethod: MfaMethod) => Promise<void | _simplewebauthn_types.PublicKeyCredentialRequestOptionsJSON>;
    submit: (mfaMethod: MfaMethod, mfaCode: string | _simplewebauthn_types.PublicKeyCredentialRequestOptionsJSON) => Promise<void>;
    cancel: () => void;
    mfaMethods: ("sms" | "totp" | "passkey")[];
};

/**
 * Use this hook to enroll a user in MFA
 *
 * @returns initEnrollmentWithSms - starts the MFA enrollment flow for SMS
 * @returns initEnrollmentWithTotp - starts the MFA enrollment flow for TOTP
 * @returns submitEnrollmentWithSms - completes the MFA enrollment flow for SMS
 * @returns submitEnrollmentWithTotp - completes the MFA enrollment flow for TOTP
 * @returns unenrollWithSms - unenrolls the SMS MFA method
 * @returns unenrollWithTotp - unenrolls the TOTP MFA method
 * @returns showMfaEnrollmentModal - opens the MFA enrollment modal
 * @returns closeMfaEnrollmentModal - closes the MFA enrollment modal
 *
 * @example
 * const {unenrollWithSms} = useMfaEnrollment();
 *
 * <button
 *  onClick={() => {
 *    unenrollWithSms();
 *  }}
 * >
 * Unenroll in SMS MFA
 * </button>
 *
 * @example
 * const {unenrollWithTotp} = useMfaEnrollment();
 *
 * <button
 *  onClick={() => {
 *    unenrollWithTotp();
 *  }}
 * >
 *  Unenroll in TOTP MFA
 * </button>
 */
declare function useMfaEnrollment(): {
    initEnrollmentWithSms: (meta: {
        phoneNumber: string;
    }) => Promise<void>;
    initEnrollmentWithTotp: () => Promise<{
        secret: string;
        authUrl: string;
    }>;
    initEnrollmentWithPasskey: () => Promise<void>;
    submitEnrollmentWithSms: (meta: {
        phoneNumber: string;
        mfaCode: string;
    }) => Promise<void>;
    submitEnrollmentWithTotp: (meta: {
        mfaCode: string;
    }) => Promise<void>;
    submitEnrollmentWithPasskey: (meta: {
        credentialIds: string[];
    }) => Promise<void>;
    unenrollWithSms: () => Promise<void>;
    unenrollWithTotp: () => Promise<void>;
    unenrollWithPasskey: () => Promise<void>;
    showMfaEnrollmentModal: () => void;
    closeMfaEnrollmentModal: () => void;
};

declare class PrivyIframeError extends Error {
    type: PrivyIframeErrorTypesType;
    constructor(type: PrivyIframeErrorTypesType, message: string);
}
declare function errorIndicatesMfaTimeout(error: unknown): error is PrivyIframeError;
declare function errorIndicatesMfaVerificationFailed(error: unknown): error is PrivyIframeError;
declare function errorIndicatesMaxMfaRetries(error: unknown): error is PrivyIframeError;

declare const VERSION = "__VERSION__";

/**
 * `CallbackError` optionally includes a second parameter with further error details.
 */
type CallbackError<Details extends Record<string, any> | undefined = undefined> = Details extends Record<string, any> ? (error: PrivyErrorCode, details: Details) => void : (error: PrivyErrorCode) => void;
interface PrivyEvents {
    login: {
        /**
         * Callback that will execute once a `login` flow successfully completes.
         * - If `config.embeddedWallets.createOnLogin` is set to 'off' or a wallet creation flow is not applicable,
         *   this will run after the user successfully authenticates.
         * - If `config.embeddedWallets.createOnLogin` is set to 'users-without-wallets' or 'all-users',
         *   this will run after the user successfully authenticates _and_ creates their wallet (if applicable).
         * - If a user is already authenticated, this will run immediately and the `wasAlreadyAuthenticated` flag will be set to `true`.
         *
         * @param user {@link User} the `user` oject corresponding to the authenticated user
         * @param isNewUser {boolean} boolean flag indicating if this is the user's first time logging in to your app
         * @param wasAlreadyAuthenticated {boolean} - boolean flag indicating whether the user entered the application already authenticated
         * @param loginMethod {string} - the method used by the user to login
         * @param loginAccount - the account corresponding to the loginMethod used
         */
        onComplete?: (user: User, isNewUser: boolean, wasAlreadyAuthenticated: boolean, loginMethod: LoginMethod | null, loginAccount: LinkedAccountWithMetadata | null) => void;
        /**
         * @experimental
         *
         * Callback that will execute once a successful OAuth login flow completes.
         * This will only run in the case of an OAuth login flow.
         *
         * This will always be called before `onComplete` in the case of an OAuth login flow.
         * If you will be doing anything after the user is logged in (e.g. sending data to your API or redirecting to an authenticated route), you should wait for `onComplete` to run.
         *
         * @param oAuthTokens {@link OAuthTokens} - the OAuth tokens returned from the OAuth provider
         */
        onOAuthLoginComplete?: (oAuthTokens: OAuthTokens) => void;
        /**
         * Callback that will execute in the case of a non-successful login.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *
         */
        onError?: CallbackError;
    };
    logout: {
        /**
         * Callback that will execute when a user successfully logs out.
         */
        onSuccess?: () => void;
    };
    connectWallet: {
        /**
         * Callback that will execute once a successful `connectWallet` completes.
         * This will not run in the case of a wallet-based authentication or link flow.
         *
         * @param wallet {@link BaseConnectedWallet} the `wallet` object correspending to the connection
         */
        onSuccess?: (wallet: BaseConnectedWallet) => void;
        /**
         * Callback that will execute in the case of a non-successful wallet connection.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         */
        onError?: CallbackError;
    };
    createWallet: {
        /**
         * Callback that will execute once on a successful embedded wallet creation.
         * This will run when `createWallet` is called manually, or when `config.embeddedWallets.createOnLogin` triggers
         * an automatic wallet creation.
         *
         * @param wallet {@link BaseConnectedWallet}- the created `wallet` object
         *
         */
        onSuccess?: (wallet: Wallet) => void;
        /**
         * Callback that will execute in the case of a non-successful wallet creation.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *
         */
        onError?: CallbackError;
    };
    linkAccount: {
        /**
         * Callback that will execute once on a successful linking of a new account/login method.
         * This will run when any of the 'link' methods are called manually.
         * @param user {@link User}- the user the account was linked to
         * @param linkMethod {@link LoginMethod}- the type of linked account
         * @param linkedAccount - the newly linked account
         */
        onSuccess?: (user: User, linkMethod: LoginMethod, linkedAccount: LinkedAccountWithMetadata) => void;
        /**
         * Callback that will execute in the case of a non-successful account linking.
         *
         * @param error {PrivyErrorCode} - the corresponding error code
         * @param details.linkMethod {LoginMethod} - the type of (attempted) linked account
         *
         */
        onError?: CallbackError<{
            linkMethod: LoginMethod;
        }>;
    };
    configureMfa: {
        /**
         * Callback that will execute when MFA is required to complete a given action.
         * @param mfaMethods {@link MfaMethod[]} - List of MFA methods that the user can choose from
         */
        onMfaRequired: (mfaMethods: MfaMethod[]) => void;
    };
    setWalletPassword: {
        /**
         * Callback that will execute once a successful `setWalletPassword` completes.
         * @param  wallet {@link Wallet}- the `wallet` object that the password was set for
         */
        onSuccess?: (wallet: Wallet) => void;
        /**
         * Callback that will execute in the case of a non-successful setWalletPassword.
         *
         * @param error {PrivyErrorCode} - the corresponding error code
         */
        onError?: CallbackError;
    };
    setWalletRecovery: {
        /**
         * Callback that will execute once a successful `setWalletRecovery` completes.
         * @param  wallet {@link Wallet}- the `walle]et` object that the recovery was set for
         */
        onSuccess?: (method: UserRecoveryMethod, wallet: Wallet) => void;
        /**
         * Callback that will execute in the case of a non-successful setWalletRecovery.
         *
         * @param error {PrivyErrorCode} - the corresponding error code
         */
        onError?: CallbackError;
    };
    signMessage: {
        /**
         * Callback that will execute once a successful `signMessage` completes.
         * This will not run in the case of a wallet-based authentication or link flow.
         * @param signature - the signature (type string) of the embedded wallet used to sign message
         */
        onSuccess?: (signature: string) => void;
        /**
         * Callback that will execute in the case of a non-successful signMessage.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *  */
        onError?: CallbackError;
    };
    signTypedData: {
        /**
         * Callback that will execute once a successful `signTypedData` completes.
         * @param signature - the signature (type string) of the embedded wallet used to sign
         */
        onSuccess?: (signature: string) => void;
        /**
         * Callback that will execute in the case of a non-successful signTypedData.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *  */
        onError?: CallbackError;
    };
    sendTransaction: {
        /**
         * Callback that will execute once a successful `sendTransaction` completes.
         * This will not run in the case of a wallet-based authentication or link flow.
         * @param response - the response (type TransactionResponse https://docs.ethers.org/v5/api/providers/types/#providers-TransactionResponse) from the successful transaction
         */
        onSuccess?: (response: TransactionResponse) => void;
        /**
         * Callback that will execute in the case of a non-successful sendTransaction.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *  */
        onError?: CallbackError;
    };
    sendSolanaTransaction: {
        /**
         * Callback that will execute once a successful `sendSolanaTransaction` completes.
         * This will not run in the case of a wallet-based authentication or link flow.
         * @param response - the response {@link https://solana-labs.github.io/solana-web3.js/types/ParsedTransactionMeta.html SolanaTransactionReceipt} from the successful transaction
         */
        onSuccess?: (response: SolanaTransactionReceipt) => void;
        /**
         * Callback that will execute in the case of a non-successful sendTransaction.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *  */
        onError?: CallbackError;
    };
    accessToken: {
        /**
         * Callback that will execute when a user's access token is granted.
         * @param accessToken - The user's access token
         */
        onAccessTokenGranted: (accessToken: string) => void;
        /**
         * Callback that will execute when a user's access token is removed.
         */
        onAccessTokenRemoved: () => void;
    };
    oAuthAuthorization: {
        /**
         * Callback that will execute when a user successfully authorizes an OAuth flow.
         *
         * @param oAuthTokens {@link OAuthTokens} - the OAuth tokens returned from the OAuth provider:
         * @param oAuthTokens.provider - {string}  The OAuth provider type.
         * @param oAuthTokens.accessToken - {string} The OAuth access token.
         * @param oAuthTokens.accessTokenExpiresInSeconds - {number} (optional) The number of seconds until the OAuth access token expires.
         * @param oAuthTokens.refreshToken - {string} (optional) The OAuth refresh token.
         * @param oAuthTokens.refreshTokenExpiresInSeconds - {number} (optional) The number of seconds until the OAuth refresh token expires.
         * if the refresh token is present and this field is undefined, it is assumed
         * that the refresh token does not have an expiration date.
         * @param oAuthTokens.scopes -  {string[]} (optional) The list of OAuth scopes the access token is approved for.
         *
         * @param o.user {@link User} (optional) The list of OAuth scopes the access token is approved for.
         */
        onOAuthTokenGrant: (oAuthTokens: OAuthTokens, o: {
            user: User;
        }) => void;
    };
    fundWallet: {
        /**
         * Callback that will execute when a funding flow is exited. This fires when a user closes a funding flow modal, for any reason.
         *
         * @param fundingMethod {@link FundingMethod} The funding method associated with the flow at time of exit. If the user had not yet selected
         * @param balance {@link BigNumber} The value for the funded wallet at the point of user exit.
         * a recovery method, this will be null.
         */
        onUserExited?: (o: {
            address: string;
            chain: Chain;
            fundingMethod: FundingMethod | 'manual' | null;
            balance: bigint | undefined;
        }) => void;
    };
    customAuth: {
        /**
         * Callback that will execute when Privy successfully exchanges a custom auth JWT for a Privy JWT
         * @param o.user - The Privy user
         */
        onAuthenticated: (o: {
            user: User;
        }) => void;
        /**
         * Callback that will execute when Privy detects a user is logged out from the third-party auth system, and correspondingly logs the user out.
         */
        onUnauthenticated: () => void;
    };
}

/**
 * Use this hook to log the user in, and to attach callbacks
 * for successful `login`s, already-`authenticated` users, and
 * `login` errors.
 *
 * @param callbacks.onComplete {@link PrivyEvents} callback to execute for already- or newly-`authenticated` users
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `login`.
 * @returns login - opens the Privy modal and prompts the user to login
 */
declare function useLogin(callbacks?: PrivyEvents['login']): {
    /**
     * Opens the Privy login modal and prompts the user to login.
     */
    login: (options?: LoginModalOptions | react.MouseEvent<any, any>) => void;
};

/**
 * Use this hook to log the user out, and to attach a callback after a successful logout.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute when a user successfully logs out.
 * @returns logout - logs the user out and clears their authentication state.
 */
declare function useLogout(callbacks?: PrivyEvents['logout']): {
    /**
     * Log the current user out and clears their authentication state. `authenticated` will become false, `user` will become null, and the Privy Auth tokens will be deleted from the browser's local storage.
     */
    logout: () => Promise<void>;
};

type UseLoginWithOAuth = {
    /**
     * Redirect to a login page for the given OAuth provider without using Privy's UI
     *
     * @returns a Promise that resolves when the redirect _(using `window.assign`)_ is complete, or rejects if there was an error.
     *
     * @example
     * const {initOAuth} = useLoginWithOAuth()
     *
     * <Button onPress={() => initOAuth({ provider: 'google' })} /> *
     */
    initOAuth: ({ provider }: {
        provider: OAuthProviderType;
    }) => Promise<void>;
    /**
     * Used to log users in via various OAuth providers without using Privy's UI
     *
     * @returns a Promise that resolves with the User if login was successful or rejects if there was an error.
     *
     * @example
     * const {loginWithOAuth} = useLoginWithOAuth()
     *
     * <Button onPress={loginWithOAuth} /> *
     */
    loginWithOAuth: () => Promise<User | undefined>;
    /**
     * Indicates a headless OAuth flow is in progress
     */
    loading: boolean;
    /**
     * The current state of the login with OAuth flow.
     */
    state: OAuthFlowState;
};
/**
 * @experimental
 *
 * Use this hook to log the user in with an OAuth provider, without using any Privy UIs.
 */
declare const useLoginWithOAuth: (callbacks?: PrivyEvents["login"]) => UseLoginWithOAuth;

type SendCodeToEmail = {
    email: string;
};
type UseLoginWithEmail = {
    /**
     * Sends a one-time-passcode (OTP) to the user's email address.
     *
     * @param opts {@link SendCodeToEmail} options for sending the OTP
     * @param opts.email {string} the user's email address
     *
     * @returns a Promise that resolves if the OTP was successfully sent to the email,
     * or rejects if there was an error.
     */
    sendCode: ({ email }: SendCodeToEmail) => Promise<void>;
    /**
     * Log a user in with a one-time-passcode (OTP) that has been sent to their
     * email address via {@link sendCode}
     *
     * For a single OTP, you may call this method up to a maximum of 5 times, to handle
     * errors where the user incorrectly enters the OTP in your UIs.
     *
     * After 5 attempts of {@link loginWithCode}, the existing OTP is no longer valid, and you
     * must request a new one for the user via {@link sendCode}
     *
     * @param opts {@link LoginWithCode} options for logging the user in with an OTP
     * @param opts.code {string} the OTP provided by the user
     *
     * @returns a Promise that resolves if the inputted OTP was valid, or rejects if there was an error.
     */
    loginWithCode: ({ code }: LoginWithCode) => Promise<void>;
    /**
     * The current state of the login with Email flow.
     */
    state: OtpFlowState;
};
/**
 * @experimental
 *
 * Use this hook to log the user in with email, without using any Privy UIs.
 *
 * @returns sendCode - {@link sendCode} sends a one-time-code to the user's email address.
 * @returns loginWithCode - {@link loginWithCode} - logs a user in with a one-time-code, maximum 5 attempts.
 * @returns state - {@link OtpFlowState} - the current state of the login with Email flow.
 */
declare const useLoginWithEmail: (callbacks?: PrivyEvents["login"]) => UseLoginWithEmail;

type UseLoginWithPasskey = {
    /**
     * Logs in a user with a passkey without using any Privy UIs.
     *
     * @returns a Promise that resolves if the passkey is valid, or rejects if there was an error.
     */
    loginWithPasskey: () => Promise<void>;
    /**
     * State of the passkey flow.
     */
    state: PasskeyFlowState;
};
/**
 * @experimental
 *
 * Use this hook to log the user in with passkey, without using any Privy UIs.
 *
 * @returns loginWithPasskey - {@link loginWithPasskey} - logs a user in with a passkey
 */
declare const useLoginWithPasskey: (callbacks?: PrivyEvents["login"]) => UseLoginWithPasskey;

type SendCodeToSms = {
    phoneNumber: string;
};
type UseLoginWithSms = {
    /**
     * Sends a one-time-passcode (OTP) to the user's phone number.
     *
     * @param opts {@link SendCodeToSms} options for sending the OTP
     * @param opts.phoneNumber {string} the user's phone number
     *
     * The phone number will ignore all non numerical values in the string except for the optional '+' first character for country code specification.
     * By default, the implicit phone number country code is +1/US. So any phone number inputted is default read as a US phone number.
     * Explicitly prepending a (+)1 to the phone number will do nothing, and the phone number will still be read and parsed as a US phone number.
     * If you are trying to send sms to a non (+1) phone number, you must append a +${countryCode} to the beginning of the input value.
     *
     * @returns a Promise that resolves if the OTP was successfully sent to the email,
     * or rejects if there was an error.
     */
    sendCode: ({ phoneNumber }: SendCodeToSms) => Promise<void>;
    /**
     * Log a user in with a one-time-passcode (OTP) that has been sent to their
     * phone number via {@link sendCode}
     *
     * For a single OTP, you may call this method up to a maximum of 5 times, to handle
     * errors where the user incorrectly enters the OTP in your UIs.
     *
     * After 5 attempts of {@link loginWithCode}, the existing OTP is no longer valid, and you
     * must request a new one for the user via {@link sendCode}
     *
     * @param opts {@link LoginWithCode} options for logging the user in with an OTP
     * @param opts.code {string} the OTP provided by the user
     *
     * @returns a Promise that resolves if the inputted OTP was valid, or rejects if there was an error.
     */
    loginWithCode: ({ code }: LoginWithCode) => Promise<void>;
    /**
     * The current state of the login with SMS flow.
     */
    state: OtpFlowState;
};
/**
 * @experimental
 *
 * Use this hook to log the user in with sms, without using any Privy UIs.
 *
 * @returns sendCode - {@link sendCode} sends a one-time-code to the user's phone number.
 * @returns loginWithCode - {@link loginWithCode} - logs a user in with a one-time-code, maximum 5 attempts.
 * @returns state - {@link OtpFlowState} - the current state of the login with Email flow.
 */
declare const useLoginWithSms: (callbacks?: PrivyEvents["login"]) => UseLoginWithSms;

type UseLinkWithSiwe = {
    /**
     * Given an external wallet address and chain ID, creates a EIP-4361 message for signing.
     * To be used for a SIWE implementation without Privy UIs
     *
     * @param opts options for generating a SIWE message for
     * @param opts.address  {string} EIP-55 mixed-case checksum-encoded address performing the signing.
     * @param opts.chainId {string} EIP-155 Chain ID to which the session is bound
     * @returns {string} EIP-4361 message for signing.
     */
    generateSiweMessage: ({ address, chainId }: {
        address: string;
        chainId: string;
    }) => Promise<string>;
    /**
     * Link a new wallet to the authenticated user via the Sign-In with Ethereum spec.
     *
     * @param opts options for verifying a signature for a SIWE message
     * @param opts.signature {string}  The EIP-191 signature corresponding to the message that the user had been given.
     * @param opts.message  {string} EIP-4361 message for signing. Returned from the generateSiweMessage call
     * @param opts.chainId {string} EIP-155 Chain ID to which the session is bound
     * @param opts.walletClientType {string}  (optional) the wallet client of the external wallet (ie. 'metamask', 'coinbase_wallet'). Defaults to null if not specified.
     * @param opts.connectorType {string}  (optional) the method used to connect the wallet to the application (ie. 'injected', 'wallet_connect_v2'). Defaults to null if not specified.
     * @returns The user response object.
     */
    linkWithSiwe: ({ signature, message, chainId, walletClientType, connectorType, }: {
        signature: string;
        message: string;
        chainId: string;
        walletClientType?: string;
        connectorType?: string;
    }) => Promise<void>;
    /**
     * The current state of the SIWE link operation
     */
    state: SiweFlowState;
};
/**
 * @experimental
 *
 * Use this hook to link an ethereum wallet to a user, without using any Privy UIs.
 *
 * @returns generateSiweMessage - {@link generateSiweMessage} generates a SIWE message for a given EIP-55 wallet address and eip-155 chain ID.
 * @returns linkWithSiwe - {@link linkWithSiwe} - Links a wallet to a user via the signature created for the SIWE message.
 */
declare const useLinkWithSiwe: (callbacks?: PrivyEvents["linkAccount"]) => UseLinkWithSiwe;

/**
 * Use this hook to register your app's logic for prompting users to complete MFA.
 * When a user is required to complete MFA in order to use their embedded wallet,
 * Privy will invoke the logic you register here to have the user complete MFA.
 * This hook should be mounted somewhere towards the root of your application tree
 * so that it can handle MFA required events from the entire application.
 *
 * @param callbacks {@link PrivyEvents} callbacks to register your logic for
 * prompting users to complete MFA.
 * @param callbacks.onMfaRequired {@link PrivyEvents} Privy will invoke this callback
 * whenever the user is required to complete MFA. Pass in a function that will prompt
 * your user to complete MFA with Privy (using `useMfa`) and only returns once
 * MFA has been completed.
 * @param callbacks.onError {@link PrivyEvents} Privy will invoke this callback whenever
 * there is an error in the MFA flow. Use this callback to define logic around how
 * you'd like to handle these errors (e.g. showing a UI to the user).
 *
 * @example
 * const [mfaMethods, setMfaMethods] = useState([])
 * const [isMfaDialogOpen, setIsMfaDialogOpen] = useState(false)
 *
 * // Prompt user to select from their enabled MFA methods
 * useRegisterMfaListener({
 *   onMfaRequired: async (methods) => {
 *     setMfaMethods(methods)
 *     setIsMfaDialogOpen(true);
 *   },
 * });
 *
 * // Within MFA modal allow the user to select an MFA method
 * <MFAModal
 *   mfaMethods={mfaMethods}
 *   isOpen={isMfaDialogOpen}
 *   setIsOpen={setIsMfaDialogOpen}
 * />
 *
 * See `useMfa` for how to execute the MFA flow within Privy in your App.
 */
declare function useRegisterMfaListener(callbacks: PrivyEvents['configureMfa']): void;

/**
 * Use this hook to link a new account to an authenticated user, and to attach
 * callbacks for success and errors.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute after a successful account linkage
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `link`.
 *
 * @returns linkEmail - opens the Privy modal and prompts the user to link an email address
 * @returns linkPhone - opens the Privy modal and prompts the user to link a phone number
 * @returns linkWallet - opens the Privy modal and prompts the user to link an external wallet
 * @returns linkGoogle - immediately redirects to Google login page and prompts the user to link their account
 * @returns linkApple - immediately redirects to Apple login page and prompts the user to link their account
 * @returns linkTwitter - immediately redirects to Twitter login page and prompts the user to link their account
 * @returns linkDiscord - immediately redirects to Discord login page and prompts the user to link their account
 * @returns linkGithub - immediately redirects to Github login page and prompts the user to link their account
 * @returns linkLinkedIn - immediately redirects to LinkedIn login page and prompts the user to link their account
 * @returns linkTikTok - immediately redirects to TikTok login page and prompts the user to link their account
 * @returns linkSpotify - immediately redirects to Spotify login page and prompts the user to link their account
 * @returns linkInstagram - immediately redirects to Instagram login page and prompts the user to link their account
 * @returns linkTelegram - immediately redirects to Telegram login page and prompts the user to link their account
 * @returns linkFarcaster - displays a QR code to sign in with Farcaster and prompts user to link their account
 *
 */
declare function useLinkAccount(callbacks?: PrivyEvents['linkAccount']): {
    linkEmail: () => void;
    linkPhone: () => void;
    linkWallet: () => void;
    linkGoogle: () => void;
    linkApple: () => void;
    linkTwitter: () => void;
    linkDiscord: () => void;
    linkGithub: () => void;
    linkLinkedIn: () => void;
    linkTiktok: () => void;
    linkSpotify: () => void;
    linkInstagram: () => void;
    linkFarcaster: () => void;
    linkTelegram: () => void;
};

/**
 * Use this hook to connect the user's external wallet, and to attach
 * callbacks after a user successfully connects their wallet, or if there
 * is an error during the connection attempt.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute when a user successfully connects their wallet
 * @param callbacks.onError {@link PrivyEvents} callback to execute when a user attempts to connect their wallet, but there is an error
 * @returns connectWallet - opens the Privy modal and prompts the user to connect an external wallet
 */
declare function useConnectWallet(callbacks?: PrivyEvents['connectWallet']): {
    /**
     * Opens the Privy modal and prompts the user to connect a wallet.
     */
    connectWallet: (options?: ConnectWalletModalOptions | react.MouseEvent<any, any>) => void;
};

/**
 * Use this hook to create a privy wallet for a user, and to attach a callback after successful wallet creation.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute when a user successfully creates a privy wallet
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `cresteWallet`.
 * @returns createWallet - creates a privy wallet for the user.
 */
declare function useCreateWallet(callbacks?: PrivyEvents['createWallet']): {
    /**
     * Creates an embedded wallet for the current user.
     *
     * This method will error if the user already has an embedded wallet
     *
     * If the `config.embeddedWallets.requireUserOwnedRecoveryOnCreate` property is set to true,
     * this will prompt the user to complete a recovery flow to secure
     * the recovery share of their embedded wallet.
     *
     * Otherwise (the default), Privy will secure the recovery share, and the embedded wallet
     * will be created without showing any UIs to the user.
     *
     * @returns Promise for the {@link Wallet} object for the newly created embedded wallet
     */
    createWallet: (options?: CreateWalletOptions | react.MouseEvent<any, any>) => Promise<Wallet>;
};

/**
 * Method to fund a user's wallet via Privy's funding feature by inputting a valid wallet address.
 * You can access the fields and methods documented here via the {@link useFundWallet} hook.
 */
interface UseFundWalletInterface {
    /**
     * Prompt the user to go through the funding flow and for a specified wallet.
     *
     * This will open the modal with a prompt for the user to select a funding method (if multiple are enabled).
     *
     * Once the user continues to the funding flow, Privy will display the funding status screen, and wait
     * for the transaction to complete.
     *
     * Note: Even after a successful funding, funds can take a few minutes to arrive in the user's wallet.
     *
     * Privy currently supports funding via external wallets and Moonpay.
     *
     * @param address typed data payload to be signed
     * @param fundWalletConfig {@link FundWalletConfig} Funding configuration to specify chain and funding amount (if enabled)
     */
    fundWallet: (address: string, fundWalletConfig?: FundWalletConfig) => Promise<void>;
}
/**
 * Hook to fund a wallet via Privy's fiat on-ramp integration given the wallet address.
 *
 * @param callbacks.onUserExited {@link PrivyEvents} Callback that will execute when a funding flow is exited. This fires when a user closes a funding flow modal, for any reason.
 * @returns fundWallet - function to on-ramp funds to any given wallet
 */
declare const useFundWallet: (callbacks?: PrivyEvents["fundWallet"]) => UseFundWalletInterface;

/**
 * Hook to headlessly connect a Coinbase Smart Wallet to a user.
 */
interface UseConnectCoinbaseSmartWalletInterface {
    /**
     * Method to headlessly connect a Coinbase Smart Wallet to a user.
     * @experimental
     */
    connectCoinbaseSmartWallet: () => void;
}
declare const useConnectCoinbaseSmartWallet: () => UseConnectCoinbaseSmartWalletInterface;

/**
 * Hook to access to link and interact with cross-app accounts from a provider app.
 * You can access the fields and methods documented here via the {@link useCrossAppAccounts} hook.
 */
interface UseCrossAppAccountsInterface {
    /**
     * For users who are not authenticated, prompts the user to log into their account from another Privy app.
     * Once a user has logged into their account, you can request signatures and transactions from their embedded wallet
     * in the linked app.
     *
     * @param options.appId {string} the target Privy app ID from which the user should log into another Privy account
     *
     * @returns a Promise that resolves if the user successfully authenticates, or rejects if there was an error
     */
    loginWithCrossAppAccount: ({ appId }: {
        appId: string;
    }) => Promise<User>;
    /**
     * For users who are authenticated, prompts the user to link their account from another Privy app to their account
     * within your app. Once a user has linked their account, you can request signatures and transactions from their embedded wallet
     * in the linked app.
     *
     * This will redirect the user to a page on the target Privy app ID where they can login and authorize access to your app.
     * @param options.appId {string} the target Privy app ID from which the user should link another Privy account
     */
    linkCrossAppAccount: ({ appId }: {
        appId: string;
    }) => Promise<User>;
    /**
     * Unlink a cross-app account from a user, by passing the apple subject ID.
     * Note that you can only unlink this account if the user has at least one other account.
     *
     * @param options.subject {string} the OAuth subject of the account to be unlinked.
     */
    unlinkCrossAppAccount: ({ subject }: {
        subject: string;
    }) => Promise<User>;
    /**
     * For users who have linked an account from another privy app, prompts the user to sign a message
     * with their embedded wallet from the linked privy app.
     *
     * This will redirect the user to a page on the target Privy app where they can sign the message.
     *
     *
     * @param message {string} the message to sign
     * @param options.address {string} the address of the embedded wallet from the linked privy app
     */
    signMessage: (message: string, o: {
        address: string;
    }) => Promise<string>;
    /**
     * For users who have linked an account from another privy app, prompts the user to sign typed data
     * with their embedded wallet from the linked privy app.
     *
     * This will redirect the user to a page on the target Privy app where they can sign the message.
     *
     *
     * @param data {SignTypedDataParameters} the typed data to sign
     * @param options.address {string} the address of the embedded wallet from the linked privy app
     */
    signTypedData: (data: SignTypedDataParams, o: {
        address: string;
    }) => Promise<string>;
    /**
     * For users who have linked an account from another privy app, prompts the user to send a
     * transaction with their embedded wallet from the linked privy app.
     *
     * This will redirect the user to a page on the target Privy app where they can sign the message.
     *
     *
     * @param tx {UnsignedTransactionRequestWithChainId} the transaction to send
     * @param options.address {string} the address of the embedded wallet from the linked privy app
     */
    sendTransaction: (tx: UnsignedTransactionRequestWithChainId, o: {
        address: string;
    }) => Promise<string>;
}
/**
 * Hook to use cross-app accounts
 *
 * @experimental
 * @returns o.linkCrossAppAccount - method to link a user's account from a provider app
 * @returns o.signMessage - method sign a message with a user's embedded wallet from a provider app
 */
declare const useCrossAppAccounts: () => UseCrossAppAccountsInterface;

/**
 * Use this hook to send a transaction using the embedded wallet and to attach callbacks for success and errors.
 * Transactions sent from the embedded wallet using transaction functions from non-Privy libraries
 * will not trigger the callbacks.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful transaction sent
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `sendTransaction`
 * @returns sendTransaction - prompts the user send a transaction using their embedded wallet
 */
declare function useSendTransaction(callbacks?: PrivyEvents['sendTransaction']): {
    /**
     * Prompts a user to send a transaction using their embedded wallet.
     */
    sendTransaction: (data: UnsignedTransactionRequest, uiOptions?: SendTransactionModalUIOptions, fundWalletConfig?: FundWalletConfig, address?: string) => Promise<TransactionReceipt>;
};

/**
 * Use this hook to send a transaction using the embedded wallet and to attach callbacks for success and errors.
 * Transactions sent from the embedded wallet using transaction functions from non-Privy libraries
 * will not trigger the callbacks.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful transaction sent
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `sendSolanaTransaction`
 * @returns sendSolanaTransaction - prompts the user send a transaction using their embedded wallet
 */
declare function useSendSolanaTransaction(callbacks?: PrivyEvents['sendSolanaTransaction']): {
    /**
     * Prompts a user to send a transaction using their embedded wallet.
     */
    sendSolanaTransaction: (transaction: SupportedSolanaTransaction, connection: _solana_web3_js.Connection, uiOptions?: SendTransactionModalUIOptions, transactionOptions?: _solana_wallet_adapter_base.SendTransactionOptions) => Promise<SolanaTransactionReceipt>;
};

/**
 * Use this hook to set a password on the embedded wallet, and to attach callbacks
 * for successful `password set`s, and `password set` errors.
 * Note that the callbacks will only fire for explicit `setWalletPassword` calls from the Privy SDK.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful password setting
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `setWalletPassword` -- ie.
 * the user doesn't have an embedded wallet, the user already has a set password on the wallet, or the password flow is prematurely exited.
 * @returns setWalletPassword - opens the Privy modal and prompts the user to set a password on the embedded wallet
 */
declare function useSetWalletPassword(callbacks?: PrivyEvents['setWalletPassword']): {
    /**
     * Opens the Privy set password modal and prompts the user to set wallet password.
     */
    setWalletPassword: () => Promise<Wallet>;
};

/**
 * Use this hook to create a guest account
 *
 * @returns createGuestAccount - {@link createGuestAccount} creates a guest account
 */
declare function useGuestAccounts(): {
    createGuestAccount: () => Promise<User>;
};

/**
 * Use this hook to set user-controlled recovery on the embedded wallet, and to attach callbacks
 * for successful `recovery set`s, and `recovery set` errors.
 * Note that the callbacks will only fire for explicit `setWalletRecovery` calls from the Privy SDK.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful recovery setting
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `setWalletRecovery` -- ie.
 * the user doesn't have an embedded wallet, the user already has a cloud-based recovery on the wallet, or the password flow is prematurely exited.
 * @returns setWalletRecovery - opens the Privy modal and prompts the user to set a password on the embedded wallet
 */
declare function useSetWalletRecovery(callbacks?: PrivyEvents['setWalletRecovery']): {
    /**
     * Opens the Privy set recovery modal and prompts the user to set wallet password.
     */
    setWalletRecovery: (o?: SetWalletRecoveryOptions) => Promise<Wallet>;
};

/**
 * Use this hook to sign a message using the embedded wallet, and to attach callbacks for success and errors.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful message signature
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `signMessage`
 * @returns signMessage - prompts the user to sign a message with their embedded wallet
 */
declare function useSignMessage(callbacks?: PrivyEvents['signMessage']): {
    /**
     * Prompts a user to sign a message using their embedded wallet.
     */
    signMessage: (message: string, uiOptions?: SignMessageModalUIOptions, address?: string) => Promise<string>;
};

/**
 * Use this hook to sign typed data using the embedded wallet, and to attach callbacks for success and errors.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful signature
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `signTypedData`
 * @returns signTypedData - prompts the user to sign typed data with their embedded wallet
 */
declare function useSignTypedData(callbacks?: PrivyEvents['signTypedData']): {
    /**
     * Prompts a user to sign typed data using their embedded wallet.
     */
    signTypedData: (typedData: SignTypedDataParams, uiOptions?: SignMessageModalUIOptions, address?: string) => Promise<string>;
};

/**
 * Use this hook to check whether or not the Privy modal is currently visible.
 *
 * @returns isOpen - whether or not the Privy modal is visible
 */
declare const useModalStatus: () => {
    isOpen: boolean;
};

/**
 * Use this hook to tap into access token grant and revoke events.
 *
 * @param callbacks.onAccessTokenGranted {@link PrivyEvents} callback to automatically execute when a user is granted an access token. This will be called when a user logs in, or when a user's access token is refreshed.
 * @param callbacks.onAccessTokenRemoved {@link PrivyEvents} callback to automatically execute when a user's access token is revoked.
 * @returns getAccessToken - returns the user's current access token
 */
declare function useToken(callbacks?: PrivyEvents['accessToken']): {
    getAccessToken: () => Promise<string | null>;
};

type UseOAuthTokens = {
    /**
     * For users who are authenticated, prompts the user to reauthorize an OAuth account of the specified type.
     * This will directly initiate the OAuth flow for an already linked OAuth account.
     */
    reauthorize: ({ provider }: {
        provider: OAuthProviderType;
    }) => Promise<void>;
};
/**
 * Use this hook to retrieve the user's OAuth tokens after any subsequent OAuth Authorization flow.
 * Ensure that this callback is mounted whenever your user undergoes a successful OAuth authorization flow to access the OAuth and Refresh tokens.
 *
 * @param callbacks.onOAuthTokenGrant {@link PrivyEvents} callback to automatically execute when a user is granted an OAuth token during an OAuth flow.
 *
 * @returns reauthorize.reauthorize {@link UseOAuthTokens} triggers the OAuth authorization fow for an existing account
 */
declare function useOAuthTokens(callbacks?: PrivyEvents['oAuthAuthorization']): UseOAuthTokens;

type UseCustomAuth = {
    /**
     * Object that indicates the status of Privy's custom auth flow.
     *
     * Possible values include: {
     * status: 'initial' | 'loading' | 'not-enabled' | 'done';
     * }
     * or {
     * status: 'error';
     * error: Error | null;
     * }
     *
     */
    status: CustomAuthFlowState;
};
/**
 * Use this hook to check the Privy auth flow status for whenever third-party/custom auth is enabled.
 *
 * @returns status - auth flow/ JWT exchange status of the Privy user, if custom auth is enabled
 */
declare const useCustomAuth: (callbacks?: PrivyEvents["customAuth"]) => UseCustomAuth;

/**
 * @deprecated Use `useFarcasterSigner` instead.
 */
declare const useExperimentalFarcasterSigner: typeof useFarcasterSigner;
/**
 * Use this hook to write to Farcaster. This hook is experimental and subject to change.
 *
 * @experimental
 */
declare function useFarcasterSigner(): {
    getFarcasterSignerPublicKey: () => Promise<Uint8Array>;
    signFarcasterMessage: (messageHash: Uint8Array) => Promise<Uint8Array>;
    requestFarcasterSignerFromWarpcast: () => Promise<void>;
};

/**
 * Allows you to override the RPC url for the given chain
 *
 * @param chain {@link Chain} chain you want to modify
 * @param rpcUrl {@type string} rpc url you want to use for this chain
 * @returns modified chain object
 *
 * @example
 *
 * ```ts
 * import { mainnet } from 'viem/chains';
 * import { addRpcUrlOverrideToChain } from '@privy-io/react-auth';
 *
 * const mainnetOverride = addRpcUrlOverrideToChain(mainnet, INSERT_MAINNET_OVERRIDE_URL);
 * ```
 */
declare function addRpcUrlOverrideToChain(chain: Chain, rpcUrl: string): {
    rpcUrls: {
        privyWalletOverride: {
            http: string[];
        };
        default: {
            http: readonly string[];
            webSocket?: readonly string[];
        };
    } | {
        privyWalletOverride: {
            http: string[];
        };
        default: {
            http: readonly string[];
            webSocket?: readonly string[];
        };
    };
    id: number;
    name: string;
    network?: string;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
    blockExplorers?: {
        [key: string]: {
            name: string;
            url: string;
        };
        default: {
            name: string;
            url: string;
        };
    };
    testnet?: boolean;
};
declare function addPrivyRpcToChain(chain: Chain, rpcUrl: string): {
    rpcUrls: {
        privy: {
            http: string[];
        };
        default: {
            http: readonly string[];
            webSocket?: readonly string[];
        };
    } | {
        privy: {
            http: string[];
        };
        default: {
            http: readonly string[];
            webSocket?: readonly string[];
        };
        privyWalletOverride: {
            http: readonly string[];
            webSocket?: readonly string[];
        };
    };
    id: number;
    name: string;
    network?: string;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
    blockExplorers?: {
        [key: string]: {
            name: string;
            url: string;
        };
        default: {
            name: string;
            url: string;
        };
    };
    testnet?: boolean;
};

/**
 * Get the embedded wallet for the user if they have one.
 *
 * @param wallets {@link ConnectedWallet} the array of wallets fetched via {@link useWallets}
 * @returns the embedded wallet if it exists, otherwise null
 */
declare function getEmbeddedConnectedWallet(wallets: ConnectedWallet[]): ConnectedWallet | null;

declare const LoginModal: ({ open }: {
    open: boolean;
}) => react_jsx_runtime.JSX.Element;

export { type CallbackError, Captcha, ConnectWalletModalOptions, ConnectedWallet, ConnectorManager, CustomAuthFlowState, EIP1193Provider, EthereumWalletConnector, FundWalletConfig, LoginModal, LoginModalOptions, LoginWithCode, MfaMethod, OAuthFlowState, OAuthProviderType, OAuthTokens, OtpFlowState, PasskeyFlowState, PrivyClient, PrivyClientConfig, type PrivyEvents, type PrivyInterface, PrivyProvider, type PrivyProviderProps, PrivyProxyProvider, DEFAULT_SUPPORTED_CHAINS as SUPPORTED_CHAINS, type SendCodeToEmail, type SendCodeToSms, SendTransactionModalUIOptions, SignMessageModalUIOptions, SignTypedDataParams, SiweFlowState, SolanaTransactionReceipt, SupportedSolanaTransaction, TransactionReceipt, UnsignedTransactionRequest, type UseConnectCoinbaseSmartWalletInterface, type UseCustomAuth, type UseFundWalletInterface, type UseLoginWithEmail, type UseLoginWithPasskey, type UseLoginWithSms, type UseOAuthTokens, type UseWalletsInterface, User, VERSION, Wallet, WalletConnector, WalletListEntry, addPrivyRpcToChain, addRpcUrlOverrideToChain, errorIndicatesMaxMfaRetries, errorIndicatesMfaTimeout, errorIndicatesMfaVerificationFailed, getAccessToken, getEmbeddedConnectedWallet, useConnectCoinbaseSmartWallet, useConnectWallet, useCreateWallet, useCrossAppAccounts, useCustomAuth, useExperimentalFarcasterSigner, useFarcasterSigner, useFundWallet, useGuestAccounts, useLinkAccount, useLinkWithSiwe, useLogin, useLoginWithEmail, useLoginWithOAuth, useLoginWithPasskey, useLoginWithSms, useLogout, useMfa, useMfaEnrollment, useModalStatus, useOAuthTokens, usePrivy, useRegisterMfaListener, useSendSolanaTransaction, useSendTransaction, useSetWalletPassword, useSetWalletRecovery, useSignMessage, useSignTypedData, useToken, useWallets };
