import{c as e,b as t,n as a,u as s,h as n,P as r}from"./privy-context.mjs";import{ErrorCode as i}from"@ethersproject/logger";import o from"eventemitter3";import{a as l}from"./user.mjs";var d,c;(c=d||(d={})).MISSING_OR_INVALID_PRIVY_APP_ID="missing_or_invalid_privy_app_id",c.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID="missing_or_invalid_privy_account_id",c.INVALID_DATA="invalid_data",c.LINKED_TO_ANOTHER_USER="linked_to_another_user",c.ALLOWLIST_REJECTED="allowlist_rejected",c.OAUTH_USER_DENIED="oauth_user_denied",c.UNKNOWN_AUTH_ERROR="unknown_auth_error",c.USER_EXITED_AUTH_FLOW="exited_auth_flow",c.MUST_BE_AUTHENTICATED="must_be_authenticated",c.UNKNOWN_CONNECT_WALLET_ERROR="unknown_connect_wallet_error",c.GENERIC_CONNECT_WALLET_ERROR="generic_connect_wallet_error",c.CLIENT_REQUEST_TIMEOUT="client_request_timeout",c.INVALID_CREDENTIALS="invalid_credentials";class _ extends Error{toString(){return`${this.type}${this.privyErrorCode?`-${this.privyErrorCode}`:""}: ${this.message}${this.cause?` [cause: ${this.cause}]`:""}`}constructor(e,t,a){super(e),t instanceof Error&&(this.cause=t),this.privyErrorCode=a}}class E extends _{constructor(e,t,a){super(e),this.type="provider_error",this.code=t,this.data=a}}let u={UNKNOWN_ERROR:{eipCode:0,message:"Unknown error",detail:"Unknown error",retryable:!0},E4001_DEFAULT_USER_REJECTED_REQUEST:{eipCode:4001,message:"User Rejected Request",detail:"The user rejected the request.",default:!0,retryable:!0},E4100_DEFAULT_UNAUTHORIZED:{eipCode:4100,message:"Unauthorized",detail:"The requested method and/or account has not been authorized by the user.",default:!0,retryable:!1},E4200_DEFAULT_UNSUPPORTED_METHOD:{eipCode:4200,message:"Unsupported Method",detail:"The Provider does not support the requested method.",default:!0,retryable:!1},E4900_DEFAULT_DISCONNECTED:{eipCode:4900,message:"Disconnected",detail:"The Provider is disconnected from all chains.",default:!0,retryable:!0},E4901_DEFAULT_CHAIN_DISCONNECTED:{eipCode:4901,message:"Chain Disconnected",detail:"The Provider is not connected to the requested chain.",default:!0,retryable:!0},E32700_DEFAULT_PARSE_ERROR:{eipCode:-32700,message:"Parse error",detail:"Invalid JSON",default:!0,retryable:!1},E32600_DEFAULT_INVALID_REQUEST:{eipCode:-32600,message:"Invalid request",detail:"JSON is not a valid request object",default:!0,retryable:!1},E32601_DEFAULT_METHOD_NOT_FOUND:{eipCode:-32601,message:"Method not found",detail:"Method does not exist",default:!0,retryable:!1},E32602_DEFAULT_INVALID_PARAMS:{eipCode:-32602,message:"Invalid params",detail:"Invalid method parameters",default:!0,retryable:!1},E32603_DEFAULT_INTERNAL_ERROR:{eipCode:-32603,message:"Internal error",detail:"Internal JSON-RPC error",default:!0,retryable:!0},E32000_DEFAULT_INVALID_INPUT:{eipCode:-32e3,message:"Invalid input",detail:"Missing or invalid parameters",default:!0,retryable:!1},E32001_DEFAULT_RESOURCE_NOT_FOUND:{eipCode:-32001,message:"Resource not found",detail:"Requested resource not found",default:!0,retryable:!1},E32002_DEFAULT_RESOURCE_UNAVAILABLE:{eipCode:-32002,message:"Resource unavailable",detail:"Requested resource not available",default:!0,retryable:!0},E32003_DEFAULT_TRANSACTION_REJECTED:{eipCode:-32003,message:"Transaction rejected",detail:"Transaction creation failed",default:!0,retryable:!0},E32004_DEFAULT_METHOD_NOT_SUPPORTED:{eipCode:-32004,message:"Method not supported",detail:"Method is not implemented",default:!0,retryable:!1},E32005_DEFAULT_LIMIT_EXCEEDED:{eipCode:-32005,message:"Limit exceeded",detail:"Request exceeds defined limit",default:!0,retryable:!1},E32006_DEFAULT_JSON_RPC_VERSION_NOT_SUPPORTED:{eipCode:-32006,message:"JSON-RPC version not supported",detail:"Version of JSON-RPC protocol is not supported",default:!0,retryable:!1},E32002_CONNECTION_ALREADY_PENDING:{eipCode:-32002,message:"Connection request already pending",detail:"Don’t see your wallet? Check your other browser windows.",retryable:!1},E32002_REQUEST_ALREADY_PENDING:{eipCode:-32002,message:"Resource request already pending",detail:"Don’t see your wallet? Check your other browser windows.",retryable:!1},E32002_WALLET_LOCKED:{eipCode:-32002,message:"Wallet might be locked",detail:"Don’t see your wallet? Check your other browser windows.",retryable:!1},E4001_USER_REJECTED_REQUEST:{eipCode:4001,message:"Signature rejected",detail:"Please try signing again.",retryable:!0}};class h extends E{constructor(e){super(e.message,e.code,e.data);let t=Object.values(u).find((t=>t.eipCode===e.code));this.details=t||u.UNKNOWN_ERROR,-32002===e.code&&(e.message?.includes("already pending for origin")?e.message?.includes("wallet_requestPermissions")?this.details=u.E32002_CONNECTION_ALREADY_PENDING:this.details=u.E32002_REQUEST_ALREADY_PENDING:e.message?.includes("Already processing")&&e.message.includes("eth_requestAccounts")&&(this.details=u.E32002_WALLET_LOCKED))}}class p extends e{constructor(){super("Wallet timeout"),this.type="wallet_error"}}class m extends e{constructor(){super("User rejected connection"),this.type="wallet_error"}}const y=t=>{if(t instanceof e)return t;if(t?.code&&t?.reason){let e=new R(t);return t.code===i.ACTION_REJECTED&&(e.details=u.E4001_USER_REJECTED_REQUEST),e}return t?.code?new R(t):new e("Unknown connector error",t)};class T extends t{constructor(e,t,a){super(e),this.type="provider_error",this.code=t,this.data=a}}class R extends T{constructor(e){super(e.message,e.code,e.data);let t=Object.values(u).find((t=>t.eipCode===e.code));this.details=t||u.UNKNOWN_ERROR,-32002===e.code&&(e.message?.includes("already pending for origin")?e.message?.includes("wallet_requestPermissions")?this.details=u.E32002_CONNECTION_ALREADY_PENDING:this.details=u.E32002_REQUEST_ALREADY_PENDING:e.message?.includes("Already processing")&&e.message.includes("eth_requestAccounts")&&(this.details=u.E32002_WALLET_LOCKED))}}const g={ERROR_USER_EXISTS:{message:"User already exists for this address",detail:"Try another address!",retryable:!1},ERROR_TIMED_OUT:{message:"Wallet request timed out",detail:"Please try connecting again.",retryable:!0},ERROR_WALLET_CONNECTION:{message:"Could not log in with wallet",detail:"Please try connecting again.",retryable:!0},ERROR_USER_REJECTED_CONNECTION:{message:"You rejected the request",detail:"Please try connecting again.",retryable:!0},ERROR_USER_LIMIT_REACHED:{message:"Unable to link",detail:"You've reached the maximum number of linked wallets.",retryable:!1},...u};class C extends o{constructor(e){super(),this.walletClientType=e,this.connected=!1,this.initialized=!1}}const w=["metamask","phantom","brave_wallet","rainbow","uniswap_wallet_extension","uniswap_extension","rabby_wallet","crypto.com_wallet_extension","coinbase_wallet","coinbase_smart_wallet","metamask","trust","safe","rainbow","uniswap","zerion","argent","spot","omni","cryptocom","blockchain","safepal","bitkeep","zengo","1inch","binance","exodus","mew_wallet","alphawallet","keyring_pro","mathwallet","unstoppable","obvious","ambire","internet_money_wallet","coin98","abc_wallet","arculus_wallet","haha","cling_wallet","broearn","copiosa","burrito_wallet","enjin_wallet","plasma_wallet","avacus","bee","pitaka","pltwallet","minerva","kryptogo","prema","slingshot","kriptonio","timeless","secux","bitizen","blocto","okx_wallet","safemoon","rabby_wallet","privy","unknown","phantom","solflare","glow"];function N(e){return"solana"===e.chainType}function A(e){return"solana"===e.type}class D extends C{get isInstalled(){return"Installed"===this.adapter.readyState}buildConnectedWallet(e,t){let s,n,r;if("Installed"!==e.readyState||!e.publicKey)throw Error("Wallet is not connected.");return"signMessage"in e&&(s=async(...t)=>{if(!e.connected)throw Error("Wallet is not connected.");return await e.signMessage(t[0])}),"sendTransaction"in e&&(n=async(...t)=>await e.sendTransaction(t[0],t[1],t[2])),"signTransaction"in e&&(r=async t=>await e.signTransaction(t)),{type:"solana",address:e.publicKey.toBase58(),meta:t,imported:!1,connectedAt:Date.now(),walletClientType:this.walletClientType,connectorType:this.connectorType,isConnected:async()=>e.connected,disconnect:()=>{try{e.disconnect()}catch(e){console.error("Wallet does not support programmatic disconnect")}},getProvider:a,signMessage:s,sendTransaction:n,signTransaction:r}}async syncAccounts(){if("Installed"===this.adapter.readyState&&this.adapter.publicKey){let e={name:this.walletBranding.name,icon:"string"==typeof this.walletBranding.icon?this.walletBranding.icon:void 0,id:this.walletBranding.id};this.wallets.find((e=>this.adapter.publicKey&&e.address===this.adapter.publicKey.toBase58()))||(this.wallets=[this.buildConnectedWallet(this.adapter,e)],this.emit("walletsUpdated"))}else this.wallets.length>0&&(this.wallets=[],this.emit("walletsUpdated"))}get walletBranding(){return{id:this.adapter.name,name:this.adapter.name,icon:this.adapter.icon}}async initialize(){this.subscribeListeners(),await this.syncAccounts(),this.shouldAutoConnect&&await this.adapter.autoConnect().catch(console.error),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}async getConnectedWallet(){return this.wallets.sort(((e,t)=>t.connectedAt-e.connectedAt))[0]||null}async isConnected(){return this.adapter.connected&&["Installed"].includes(this.adapter.readyState)}subscribeListeners(){this.adapter.addListener("disconnect",this.onDisconnect),this.adapter.addListener("connect",this.onConnect),this.adapter.addListener("error",this.onError),this.adapter.addListener("readyStateChange",this.onReadyStateChange)}unsubscribeListeners(){this.adapter.removeAllListeners()}constructor(e,t){super(function(e){return w.includes(e)}(e.name.toLowerCase())?e.name.toLowerCase():"unknown"),this.chainType="solana",this.connectorType="solana_adapter",this.disconnect=()=>{this.adapter.disconnect().then((()=>this.onDisconnect())).catch((e=>console.error("Error disconnecting",e)))},this.promptConnection=async()=>{try{await this.adapter.connect()}catch(e){throw y(e)}},this.onDisconnect=()=>{this.syncAccounts()},this.onConnect=e=>{this.syncAccounts()},this.onError=e=>{this.syncAccounts()},this.onReadyStateChange=e=>{"Installed"!==e&&(this.connected=!1),this.syncAccounts()},this.adapter=e,this.shouldAutoConnect=t,this.wallets=[]}}const b=()=>{let{embeddedSolanaWallet:e,exportSolanaWallet:t,createEmbeddedSolanaWallet:a,solanaWallets:i,initDelegateAction:o}=s(),{user:d}=n();return{createWallet:a,exportWallet:t,delegateWalletAction:async()=>{let e=l(d);if(!e)throw new r("User must have a solana wallet in order to delegate actions");return await o({address:e.address})},wallets:i.concat(e?[e]:[])}};export{g as C,u as E,R as P,D as S,m as U,p as W,C as a,T as b,A as c,y as f,N as i,h as l,b as u};
