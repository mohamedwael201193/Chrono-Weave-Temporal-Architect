import{PrivyClientError as e}from"../Error.mjs";import{getWalletPublicKeyFromTransaction as t}from"../solana/getWalletPublicKeyFromTransaction.mjs";import{isVersionedTransaction as r}from"../solana/isVersionedTransaction.mjs";import{isUnifiedWallet as a}from"../wallet-api/unified-wallet.mjs";import{errorIndicatesRecoveryIsNeeded as s}from"./errors.mjs";import{walletRpc as i}from"./stack/walletRpc.mjs";import"./types.mjs";import"../utils/encodings.mjs";import"../wallet-api/rpc.mjs";import"@privy-io/public-api";import"../wallet-api/generate-authorization-signature.mjs";import"canonicalize";import"./stack/wallet-api-eth-transaction.mjs";import"./stack/wallet-api-eth-typed-data.mjs";class n{async request(t){if(!await this._privyInternal.getAccessToken())throw new e({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});switch(t.method){case"signAndSendTransaction":return await this.handleSignAndSendTransaction(t);case"signTransaction":return await this.handleSignTransaction(t);default:return await this.handleIFrameRpc(t)}}get _publicKey(){return this._account.address}async connectAndRecover(t){if("privy-v2"!==this._account.recovery_method)try{await this._proxy.connect({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:t})}catch(r){let a=s(r);if(a&&"privy"===this._account.recovery_method)await this._proxy.recover({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:t});else{if(!a||!this._onNeedsRecovery)throw r;{let t;await new Promise((async(r,a)=>{t=setTimeout((()=>a(new e({code:"embedded_wallet_recovery_error",error:"User-owned recovery timed out"}))),12e4),await(this._onNeedsRecovery?.({recoveryMethod:this._account.recovery_method,onRecovered:()=>r(!0)}))})).finally((()=>clearTimeout(t)))}}}}async signMessageRpc(e,t){let r=this._account;if(!a(r))return(await this._proxy.rpcWallet({accessToken:t,request:e,chainType:"solana",hdWalletIndex:this._account.wallet_index,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier})).response.data;{let{data:a}=await i({context:{app:this._app,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e),signRequest:({message:e})=>this._proxy.signWithUserSigner({accessToken:t,message:e})},account:r,rpcRequest:{chainType:"solana",request:e}});return{signature:a}}}async handleIFrameRpc(t){try{let e=await this._privyInternal.getAccessToken();if(!e)throw Error("Missing privy token. User must be logged in");return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:t.method,address:this._account.address}),await this.connectAndRecover(e),await this.signMessageRpc(t,e)}catch(r){console.error(r);let a=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:t.method,address:this._account.address,error:a}),new e({code:"embedded_wallet_request_error",error:a})}}async handleSignAndSendTransaction(a){try{let e=await this._privyInternal.getAccessToken();if(!e)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:a.method,address:this._account.address}),await this.connectAndRecover(e);let{transaction:s,connection:i,options:n}=a.params,o=t(s,this._account.address),c=r(s)?Buffer.from(s.message.serialize()):s.serializeMessage(),{signature:d}=await this.signMessageRpc({method:"signMessage",params:{message:c.toString("base64")}},e);return s.addSignature(o,Buffer.from(d,"base64")),{signature:await i.sendRawTransaction(s.serialize(),n)}}catch(t){console.error(t);let r=t instanceof Error?t.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:a.method,address:this._account.address,error:r}),new e({code:"embedded_wallet_request_error",error:r})}}async handleSignTransaction(a){try{let e=await this._privyInternal.getAccessToken();if(!e)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:a.method,address:this._account.address}),await this.connectAndRecover(e);let{transaction:s}=a.params,i=t(s,this._account.address),n=r(s)?Buffer.from(s.message.serialize()):s.serializeMessage(),{signature:o}=await this.signMessageRpc({method:"signMessage",params:{message:n.toString("base64")}},e);return s.addSignature(i,Buffer.from(o,"base64")),{signedTransaction:s}}catch(t){console.error(t);let r=t instanceof Error?t.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:a.method,address:this._account.wallet_index,error:r}),new e({code:"embedded_wallet_request_error",error:r})}}toJSON(){return`PrivyEmbeddedSolanaProvider { address: '${this._account.address}', request: [Function] }`}constructor({proxy:e,privyInternal:t,account:r,entropyId:a,entropyIdVerifier:s,onNeedsRecovery:i,app:n}){this._proxy=e,this._privyInternal=t,this._account=r,this._entropyId=a,this._entropyIdVerifier=s,this._onNeedsRecovery=i,this._app=n}}export{n as EmbeddedSolanaWalletProvider};
