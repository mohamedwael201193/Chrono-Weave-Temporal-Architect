import{z as e}from"zod";import{WalletAddress as t,SolanaWalletAddress as i}from"../core.mjs";import{HPKEEncryption as r}from"./export.mjs";import{BaseWalletApiCreateInput as s}from"./wallets/index.mjs";import"bs58";import"libphonenumber-js/max";import"viem";import"@privy-io/api-base";import"../api.mjs";import"../transaction.mjs";import"./wallets/spark/index.mjs";import"./wallets/spark/utils.mjs";const o=e.enum(["ethereum","solana"]),p=e.enum(["private-key"]);let a=e.union([t,i]),n=e=>"solana"===e.chain_type?i.safeParse(e.address).success:"ethereum"===e.chain_type&&t.safeParse(e.address).success;const m=e.object({address:a,chain_type:o,entropy_type:p,encryption_type:r}).strict().refine(n,"Invalid address for specified chain type."),c=e.object({encryption_type:r,encryption_public_key:e.string()}),d=s.omit({chain_type:!0,authorization_key_ids:!0,authorization_threshold:!0}).extend({wallet:e.object({address:a,chain_type:o,entropy_type:p,ciphertext:e.string(),encapsulated_key:e.string(),encryption_type:r})}).strict().refine((e=>n(e.wallet)),"Invalid address for specified chain type.");export{m as WalletImportInitInput,c as WalletImportInitResponse,d as WalletImportSubmitInput,o as WalletImportSupportedChains,p as WalletImportSupportedEntropyTypes};
