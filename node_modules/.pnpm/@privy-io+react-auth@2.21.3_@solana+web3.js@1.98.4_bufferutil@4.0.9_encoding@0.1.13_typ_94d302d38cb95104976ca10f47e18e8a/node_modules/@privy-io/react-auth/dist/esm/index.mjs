import{g as e,a as t,u as r,b as o,c as n,C as s,d as i,s as l,U as d,e as h,f as w,t as p,h as m,M as y,i as f,A,j as k,k as C,L as v,l as E,I as S,T,S as U,B as I,P as W,E as P,m as M,n as F,o as L,p as H,q as D,G as x,W as q,r as z,v as j,w as B,x as G,y as J,z as ee,D as te,F as re,H as ae,J as oe}from"./privy-provider-Bwu3yabw.mjs";export{O as Captcha,Q as ConnectorManager,V as EthereumWalletConnector,a9 as LoginModal,a2 as PrivyClient,K as PrivyProvider,a1 as VERSION,R as WalletConnector,$ as errorIndicatesMaxMfaRetries,a0 as errorIndicatesMfaTimeout,_ as errorIndicatesMfaVerificationFailed,N as getAccessToken,a6 as useCreateWallet,a3 as useIdentityToken,a8 as useImportWallet,a4 as useLogout,Y as useMfa,Z as useMfaEnrollment,aa as useMigrateWallets,X as usePrivy,a5 as useRegisterMfaListener,a7 as useSolanaWallets}from"./privy-provider-Bwu3yabw.mjs";import{useCallback as ne,useMemo as se,useEffect as ie,useContext as le,useState as ce,useRef as ue}from"react";import{P as de,a as he}from"./paths-DCwuPDUk.mjs";import{u as we,I as pe}from"./internal-context-qdNgTV5f.mjs";import{u as me,P as ye,g as ge,a as fe,b as Ae,c as ke}from"./use-sign-with-user-signer-DYa7HrQH.mjs";export{c as useActiveWallet,a as useConnectWallet,b as useFundWallet,u as useLogin}from"./useActiveWallet-DHeanLeY.mjs";import{F as Ce}from"./frame-DMd4vZ0H.mjs";import{MfaAuthTotpVerify as ve,MfaAuthPasskeyInit as Ee,MfaAuthPasskeyVerify as Se,MfaAuthTotpInit as Te,MfaAuthTotpEnroll as Ue,MfaAuthTotpUnenroll as Ie,MfaAuthPasskeyEnrollment as We}from"@privy-io/public-api";import{jsxs as Re,Fragment as Pe,jsx as be}from"react/jsx-runtime";import Me from"@heroicons/react/24/outline/QuestionMarkCircleIcon";import Ne from"@heroicons/react/24/outline/ShieldCheckIcon";import{zeroAddress as Oe,getAddress as _e,createWalletClient as Fe,http as Le,parseSignature as He}from"viem";import{hashAuthorization as De}from"viem/utils";import{getWallet as xe,updateWallet as Ke,generateAuthorizationSignature as qe,PrivyClientError as ze}from"@privy-io/js-sdk-core";export{DEFAULT_SUPPORTED_CHAINS as SUPPORTED_CHAINS,addPrivyRpcToChain,addRpcUrlOverrideToChain}from"@privy-io/js-sdk-core";export{g as getEmbeddedConnectedWallet}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import{toAccount as je}from"viem/accounts";import"mipd";import"react-device-detect";import"uuid";import"jose";import"eventemitter3";import"@coinbase/wallet-sdk";import"@privy-io/ethereum";import"@marsidev/react-turnstile";import"styled-components";import"tinycolor2";import"@heroicons/react/24/outline/DevicePhoneMobileIcon";import"@heroicons/react/24/outline/FingerPrintIcon";import"@heroicons/react/24/outline/PhoneIcon";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/XMarkIcon";import"@heroicons/react/24/outline/CalendarIcon";import"@heroicons/react/24/outline/ExclamationTriangleIcon";import"@heroicons/react/24/outline/ChevronDownIcon";import"zustand";import"@headlessui/react";import"@heroicons/react/24/outline/CheckIcon";import"@heroicons/react/24/outline/Square2StackIcon";import"@walletconnect/ethereum-provider";import"fast-password-entropy";import"secure-password-utilities";import"secure-password-utilities/wordlists";import"@heroicons/react/24/outline/UserCircleIcon";import"@heroicons/react/24/outline/EnvelopeIcon";import"@heroicons/react/20/solid/CheckIcon";import"@heroicons/react/24/outline/WalletIcon";import"@heroicons/react/24/outline/ExclamationCircleIcon";import"@heroicons/react/24/outline/ArrowTopRightOnSquareIcon";import"@heroicons/react/24/solid/DocumentCheckIcon";import"@heroicons/react/24/solid/XCircleIcon";import"@heroicons/react/24/solid/CheckCircleIcon";import"@heroicons/react/24/outline";import"@tanstack/react-virtual";import"qrcode";import"@heroicons/react/24/solid/ArrowsRightLeftIcon";import"@heroicons/react/24/outline/ChevronRightIcon";import"@heroicons/react/24/outline/LockClosedIcon";import"@heroicons/react/24/outline/PencilSquareIcon";import"@heroicons/react/24/outline/ArrowPathIcon";import"@heroicons/react/24/outline/EyeIcon";import"@heroicons/react/24/outline/EyeSlashIcon";import"@heroicons/react/24/outline/KeyIcon";import"@heroicons/react/24/outline/ArrowDownTrayIcon";import"@heroicons/react/24/outline/ClipboardDocumentCheckIcon";import"@heroicons/react/24/outline/DocumentDuplicateIcon";import"@heroicons/react/24/solid/LockClosedIcon";import"@heroicons/react/24/outline/CheckCircleIcon";import"@heroicons/react/24/outline/InformationCircleIcon";import"@heroicons/react/24/outline/CreditCardIcon";import"@heroicons/react/24/outline/QrCodeIcon";import"@heroicons/react/24/outline/GlobeAltIcon";import"ofetch";import"@heroicons/react/24/outline/ClipboardDocumentIcon";import"@heroicons/react/24/outline/CloudArrowUpIcon";import"@heroicons/react/24/outline/NoSymbolIcon";import"@heroicons/react/24/outline/ClockIcon";import"@heroicons/react/24/outline/TrashIcon";import"@heroicons/react/24/solid/CheckBadgeIcon";import"@heroicons/react/24/solid/IdentificationIcon";import"@heroicons/react/24/outline/MinusCircleIcon";import"@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon";import"@heroicons/react/24/solid/ShieldCheckIcon";import"js-cookie";const Ve=()=>{let{user:r}=me(),{walletProxy:a}=we();return{recover:ne((async o=>{if(!a)throw Error("Wallet proxy is not ready");let n=await e();if(!r||!n)throw new de("User must be logged in before attempting to modify the recovery method.");let{entropyId:s,entropyIdVerifier:i}=t(r);try{await a.recover({entropyId:s,entropyIdVerifier:i,accessToken:n,...o})}catch{throw new de("Unable to recover wallets")}}),[a,r])}},Be=()=>{let{client:e,setAuthenticated:t,setUser:r}=we();return se((()=>({init:async()=>{if(!e)throw new de("Must initialize Privy client first.");let t=new Ce;return e.startAuthFlow(t),await t.init()},login:async({fid:a,message:o,signature:n})=>{if(!e)throw new de("Must initialize Privy client first.");if(!(e.authFlow instanceof Ce))throw new de("Must initialize Farcaster Mini App flow first.");e.authFlow.setAuthData({message:o,signature:n,fid:a});let{user:s}=await e.authenticate();if(!s)throw new de("Failed to login with Farcaster V2");return r(s),t(!0),{user:s}}})),[e,r,t])},Ge=e=>{r("login",e);let t=o(),a=n(),{ready:c,user:u}=me(),{initLoginWithHeadlessOAuth:d,loginWithHeadlessOAuth:h,oAuthState:w,setOAuthState:p,isHeadlessOAuthLoading:m}=we(),y=ne((async e=>{try{if(t.enabled&&"success"!==t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);return await d(e.provider,t.token,e.disableSignup)}catch(e){throw p({status:"error",error:e}),e}}),[d,t]),g=ne((async()=>{let e=i();try{if(u)return console.warn("Cannot login with OAuth when already logged in"),u;if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(e.popupFlow)return}catch(e){throw p({status:"error",error:e}),e}try{return await h(e)}catch(e){throw p({status:"error",error:e}),e}finally{l()}}),[h]);return ie((()=>{let e=i();c&&a&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&g().catch((()=>{}))}),[c,a]),{initOAuth:y,loading:m,state:w}},$e=e=>{let t=o(),{emailOtpState:r,setEmailOtpState:a,initLoginWithEmail:n,loginWithCode:i}=we();return{sendCode:ne((async({email:r,disableSignup:o})=>{try{let e;if(!r)throw Error("Email required to send OTP code");if(t.enabled&&"error"===t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await n({email:r,captchaToken:e,disableSignup:o,withPrivyUi:!1})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[n]),loginWithCode:ne((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);let{user:a,isNewUser:o,wasAlreadyAuthenticated:n,linkedAccount:l}=await i(r);e?.onComplete?.({user:a,isNewUser:o,wasAlreadyAuthenticated:n,loginMethod:"email",loginAccount:l})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[i,t.status]),state:r}},Qe=e=>{let t=o(),{initSignupWithPasskey:r,signupWithPasskey:a,passkeyAuthState:n,setPasskeyAuthState:i}=we();return{signupWithPasskey:ne((async()=>{try{let o;if(t.enabled&&"error"===t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),o=await t.waitForResult()),await r({captchaToken:o,withPrivyUi:!1});let{user:n,isNewUser:i,wasAlreadyAuthenticated:l,loginAccount:c}=await a();e?.onComplete?.({user:n,isNewUser:i,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||he.UNKNOWN_AUTH_ERROR),t}}),[a,t.status]),state:n}},Xe=e=>{let t=o(),{initLoginWithPasskey:r,loginWithPasskey:a,passkeyAuthState:n,setPasskeyAuthState:i}=we();return{loginWithPasskey:ne((async o=>{try{let n;if(t.enabled&&"error"===t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),n=await t.waitForResult()),await r({captchaToken:n,withPrivyUi:!1});let{user:i,isNewUser:l,wasAlreadyAuthenticated:c,loginAccount:u}=await a(o);e?.onComplete?.({user:i,isNewUser:l,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:u})}catch(o){throw i({status:"error",error:o}),e?.onError?.(o.privyErrorCode||he.UNKNOWN_AUTH_ERROR),o}}),[a,t.status]),state:n}},Je=e=>{let{initLinkWithPasskey:t,linkWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:o}=we();return{linkWithPasskey:ne((async()=>{try{await t();let a=await r();if(!a)throw Error("Error, user not found");let o=a.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:a,linkMethod:"passkey",linkedAccount:o})}catch(t){throw o({status:"error",error:t}),e?.onError?.(t.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[r]),state:a}},Ye=e=>{let t=o(),{smsOtpState:r,setSmsOtpState:a,initLoginWithSms:n,loginWithCode:i}=we();return{sendCode:ne((async({phoneNumber:r,disableSignup:o})=>{try{let e;if(!r)throw Error("SMS required to send OTP code");if(t.enabled&&"error"===t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await n({phoneNumber:r,captchaToken:e,disableSignup:o,withPrivyUi:!1})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[n]),loginWithCode:ne((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);let{user:a,isNewUser:o,wasAlreadyAuthenticated:n,linkedAccount:l}=await i(r);e?.onComplete?.({user:a,isNewUser:o,wasAlreadyAuthenticated:n,loginMethod:"sms",loginAccount:l})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[i,t.status]),state:r}},Ze=e=>{let{connectOrCreateWallet:t}=me();return r("connectOrCreateWallet",e),{connectOrCreateWallet:t}},et=e=>{let t=o(),{siweState:r,setSiweState:a,linkWithSiwe:n,generateSiweMessage:i}=we();return{generateSiweMessage:ne((async({address:t,chainId:r})=>{try{if(!t||!r)throw Error("wallet address and chainId required to generate nonce");return await i({address:t,chainId:r}).then((e=>e))}catch(t){throw a({status:"error",error:t}),e?.onError?.(t.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[i]),linkWithSiwe:ne((async({signature:r,message:o,chainId:i,walletClientType:l,connectorType:c})=>{try{if(t.enabled&&"success"!==t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);let{user:a,linkedAccount:u}=await n({message:o,signature:r,chainId:i,walletClientType:l,connectorType:c});u&&e?.onSuccess?.({user:a,linkMethod:"siwe",linkedAccount:u})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[n,t.status]),state:r}},tt=e=>{let t=o(),{siweState:r,setSiweState:a,client:n,generateSiweMessage:i,loginWithSiwe:l}=we();return{generateSiweNonce:ne((async r=>{try{let e;if(t.enabled&&"error"===t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),a({status:"generating-message"});let o=await n.generateSiweNonce({address:r?.address,captchaToken:e});return a({status:"awaiting-signature"}),o}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[n,t]),generateSiweMessage:ne((async({address:r,chainId:o})=>{try{let e;if(t.enabled&&"error"===t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await i({address:r,chainId:o,captchaToken:e})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[i,t]),loginWithSiwe:ne((async({message:r,signature:o,disableSignup:n})=>{try{let a;if(t.enabled&&"error"===t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),a=await t.waitForResult());let i=await l({message:r,signature:o,captchaToken:a,disableSignup:n});return e?.onComplete?.({user:i,isNewUser:!1,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),i}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[l,t.status]),state:r}};function rt(){let{signTransaction:e}=le(ye);return{signTransaction:e}}function at(e){let{linkEmail:t,linkPhone:a,linkWallet:o,linkGoogle:n,linkApple:s,linkTwitter:i,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkLine:h,linkSpotify:w,linkInstagram:p,linkTelegram:m,linkFarcaster:y,linkPasskey:g}=le(ye);return r("linkAccount",e),{linkEmail:t,linkPhone:a,linkWallet:o,linkGoogle:n,linkApple:s,linkTwitter:i,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkLine:h,linkSpotify:w,linkInstagram:p,linkFarcaster:y,linkTelegram:m,linkPasskey:g}}function ot(e){let{updateEmail:t,updatePhone:a}=le(ye);return r("update",e),{updateEmail:t,updatePhone:a}}const nt=e=>{let{user:t}=me(),{loginWithCode:r,emailOtpState:a,setEmailOtpState:o,client:n,inProgressAuthFlowRef:s,inProgressLoginOrLinkMethodRef:i}=we();return{state:a,sendCode:ne((async({newEmailAddress:r})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");let e=new d(t.email.address,r);n.startAuthFlow(e),await e.sendCodeEmail({withPrivyUi:!1})}catch(r){o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email]),verifyCode:ne((async({code:a})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");s.current="update",i.current="email";let{user:o,linkedAccount:n}=await r(a);return e?.onSuccess?.({user:o,updateMethod:"email",updatedAccount:n}),{user:o}}catch(a){o({status:"error",error:a}),e?.onError?.(a.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email])}},st=()=>{let{connectCoinbaseSmartWallet:e}=we();return{connectCoinbaseSmartWallet:e}},it=()=>{let{connectBaseAccount:e}=we();return{connectBaseAccount:e}},lt=()=>{let{baseAccountSdk:e}=we();return{baseAccountSdk:e}},ct=()=>{let{setModalData:e}=h(),{openModal:t,privy:r,closePrivyModal:a}=we(),{user:o}=me();return se((()=>({verify:async({standalone:n=!0}={standalone:!0})=>new Promise(((s,i)=>o?0===o.mfaMethods.length?s():(e((e=>({...e,mfaVerify:{onSuccess:async()=>{n?await a({shouldCallAuthOnSuccess:!1,isSuccess:!0}):w.setState({inProgressMfaFlow:void 0}),s()},onFailure:async e=>{n?await a({shouldCallAuthOnSuccess:!1,isSuccess:!1}):w.setState({inProgressMfaFlow:void 0}),i(e)},sendSmsCode:async()=>{throw Error("Not enabled")},verifySmsCode:async()=>{throw Error("Not enabled")},verifyTotpCode:async e=>{await r.fetchPrivyRoute(ve,{body:{code:e}})},generateOptions:async()=>p((await r.fetchPrivyRoute(Ee,{body:{}})).options),verifyPasskey:async e=>{let t=await import("@simplewebauthn/browser"),a=await t.startAuthentication(e);await r.fetchPrivyRoute(Se,{body:{authenticator_response:m(a)}})}}}))),void(n?t(y):w.setState({inProgressMfaFlow:"auth"}))):i(Error("Must be logged in to verify MFA"))))})),[r,e,t,a])},ut={component:()=>{let{user:e,ready:t}=me(),{app:r,data:a,onUserCloseViaDialogOrKeybindRef:o}=h(),[n,s]=ce(null),[i,l]=ce(null),[c,u]=ce(null),[d,w]=ce(!1),[p,m]=ce(!1),[y,g]=ce(),R=async()=>{y?b(y):e?await N({user:e}):b(Error("Must be logged in to manage MFA")),setTimeout((()=>{s(null),l(null)}),500)};if(o.current=R,!a?.mfaEnroll)throw Error("Missing modal data for MFA enrollment screen.");let{onFailure:b,onSuccess:N,mfaMethods:O,verify:_,generateTotpSecret:L,enrollTotp:H,unenrollTotp:D,enrollPasskey:x}=a.mfaEnroll,K=e?.mfaMethods.includes("sms"),q=e?.mfaMethods.includes("totp"),z=e?.mfaMethods.includes("passkey"),j=!!e?.phone,V=e?.linkedAccounts.filter((e=>"passkey"===e.type)).map((e=>e.credentialId))??[];function B(){s(null),l(null),g(void 0)}async function G(e=V){try{g(void 0),m(!0);let t=await x(e);return await N({user:t})}catch(e){g(e)}finally{m(!1),w(!1)}}if(!t||!e||!r)/*#__PURE__*/return Re(Pe,{children:[/*#__PURE__*/be(f,{onClose:R},"header"),/*#__PURE__*/be(A,{children:/*#__PURE__*/be(k,{})}),/*#__PURE__*/be(C,{children:/*#__PURE__*/be(v,{})}),/*#__PURE__*/be(E,{})]});if("sms"===n)return null;if("totp"===n)/*#__PURE__*/return Re(Pe,{children:[/*#__PURE__*/be(f,{backFn:B,onClose:R},"header"),/*#__PURE__*/be(S,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/be(Me,{})}),/*#__PURE__*/be(T,{children:"Remove authenticator app verification?"}),/*#__PURE__*/Re(U,{children:["MFA adds an extra layer of security to your ",r?.name," account. Make sure you have other methods to secure your account."]}),/*#__PURE__*/be(I,{children:/*#__PURE__*/be(W,{$warn:!0,onClick:async function(){try{g(void 0),m(!0);let e=await D();return await N({user:e})}catch(e){g(e)}finally{m(!1),s(null)}},loading:p,children:"Remove"})}),/*#__PURE__*/be(E,{})]});if("passkey"===n){let e=a.mfaEnroll.shouldUnlinkOnUnenrollMfa??!0;/*#__PURE__*/return Re(Pe,{children:[/*#__PURE__*/be(f,{backFn:B,onClose:R},"header"),/*#__PURE__*/be(S,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/be(Me,{})}),/*#__PURE__*/be(T,{children:"Are you sure you want to remove this passkey?"}),/*#__PURE__*/be(U,{children:e?"Removing your passkey will remove as both a verification method and a login method.":"Removing your passkey will remove as a verification method."}),/*#__PURE__*/be(I,{children:/*#__PURE__*/be(W,{$warn:!0,onClick:async function(){try{g(void 0),m(!0);let e=await x([]);return await N({user:e})}catch(e){g(e)}finally{m(!1),s(null)}},loading:p,children:"Remove"})}),/*#__PURE__*/be(E,{})]})}return 0!==O.length||K||q||z?"sms"===i?null:"totp"===i&&c?/*#__PURE__*/be(P,{onClose:R,onReset:B,submitEnrollmentWithTotp:e=>async function(e){try{g(void 0),m(!0);let t=await H(e);return await N({user:t})}catch(e){g(e)}finally{m(!1),s(null)}}(e.mfaCode),error:y,totpInfo:{...c,appName:r?.name||"Privy"}}):"passkey"===i?/*#__PURE__*/be(M,{onReset:B,onClose:R,submitEnrollmentWithPasskey:G}):/*#__PURE__*/be(F,{showIntro:!1,userMfaMethods:e.mfaMethods,appMfaMethods:r.mfa.methods,userHasAuthSms:j,onBackToIntro:()=>{},handleSelectMethod:async function(e){g(void 0);try{await _()}catch(e){return void g(e)}return"totp"===e?(l(e),u(null),void L().then((({totpSecret:e,totpAuthUrl:t})=>{u({authUrl:t,secret:e})})).catch((()=>{u(null),B()}))):"passkey"===e&&1===V.length?await G():void l(e)},isTotpLoading:"totp"===i&&!c,isPasskeyLoading:d,error:y,onClose:R,setRemovingMfaMethod:async function(e){g(void 0);try{await _()}catch(e){return void g(e)}s(e)}}):/*#__PURE__*/Re(Pe,{children:[/*#__PURE__*/be(f,{onClose:R},"header"),/*#__PURE__*/be(S,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/be(Ne,{})}),/*#__PURE__*/be(T,{children:"Add more security"}),/*#__PURE__*/Re(U,{children:[r?.name," does not have any verification methods enabled."]}),/*#__PURE__*/be(I,{children:/*#__PURE__*/be(W,{onClick:R,children:"Close"})}),/*#__PURE__*/be(E,{})]})}},dt=()=>{let e=L(),{setModalData:t}=h(),{verify:r}=ct(),{openModal:a,privy:o,closePrivyModal:n,refreshSessionAndUser:s,setUser:i}=we();return se((()=>({enroll:async()=>new Promise(((l,c)=>{t({mfaEnroll:{onSuccess:async e=>{await n({shouldCallAuthOnSuccess:!1,isSuccess:!0}),l(e)},onFailure:async e=>{await n({shouldCallAuthOnSuccess:!1,isSuccess:!1}),c(e)},verify:()=>r({standalone:!1}),shouldUnlinkOnUnenrollMfa:!0,mfaMethods:e.mfa.methods,sendSmsCode:async()=>{throw Error("Not enabled")},enrollSms:async()=>{throw Error("Not enabled")},unenrollSms:async()=>{throw Error("Not enabled")},generateTotpSecret:async()=>await o.fetchPrivyRoute(Te,{body:{}}),enrollTotp:async e=>{await o.fetchPrivyRoute(Ue,{body:{code:e}});let t=await s();return i(t),t},unenrollTotp:async()=>{await o.fetchPrivyRoute(Ie,{body:{}});let e=await s();return i(e),e},enrollPasskey:async e=>{await o.fetchPrivyRoute(We,{body:{credential_ids:e,remove_for_login:!0}});let t=await s();return i(t),t}}}),a(ut)}))})),[o,t,a,n])},ht=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:r,signTypedDataWithCrossAppWallet:a,sendTransactionWithCrossAppWallet:o}=me();return{loginWithCrossAppAccount:({appId:t})=>e({appId:t,action:"login"}),linkCrossAppAccount:({appId:t})=>e({appId:t,action:"link"}),unlinkCrossAppAccount:t,signMessage:r,signTypedData:a,sendTransaction:o}};function wt(e){let{sendTransaction:t}=le(ye);return r("sendTransaction",e),{sendTransaction:t}}function pt(e){let{setWalletPassword:t}=le(ye);return r("setWalletPassword",e),{setWalletPassword:t}}function mt(){let e=L(),t=H(),{client:r,setUser:a,setAuthenticated:o,setIsNewUser:n,initializeWalletProxy:s}=we(),{create:i}=D();return{createGuestAccount:async()=>{if(!e.id||!r)throw Error("SDK not yet ready");r.startAuthFlow(new x(e.id));try{let l=await r.authenticate(),c=l.user,u=l.isNewUser??!1;if(!c)throw new de("Unable to authenticate guest account");let d=await r.getAccessToken(),h=await s(q);if(d&&h)try{let t=z(c,e.embeddedWallets.ethereum.createOnLogin),r=j(c,e.embeddedWallets.solana.createOnLogin);t&&r?(c=(await i({chainType:"ethereum",latestUser:c})).user,c=(await i({chainType:"solana",latestUser:c})).user):r?c=(await i({chainType:"solana",latestUser:c})).user:t?c=(await i({chainType:"ethereum",latestUser:c})).user:a(c)}catch(e){a(c),console.warn("Unable to create embedded wallet for guest account")}return n(u),o(!0),t("login","onComplete",{user:c,isNewUser:u,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),c}catch(e){throw t("login","onError",e.privyErrorCode||he.UNKNOWN_AUTH_ERROR),e}}}}function yt(e){let{setWalletRecovery:t}=le(ye);return r("setWalletRecovery",e),{setWalletRecovery:t}}function gt(e){let{signMessage:t}=le(ye);return r("signMessage",e),{signMessage:t}}const ft=()=>{let{ready:e,wallets:t}=B(),{user:r}=me(),{rpcConfig:a,chains:o,appId:n}=we();return{signAuthorization:ne((async(s,i)=>{let l;if(!r)throw Error("User must be authenticated before signing with a Privy wallet");if(!e)throw Error("Wallets are not ready");let c=i?.address??ge(r)?.address??Oe,u=t.find((e=>_e(e.address)===_e(c)));if(!u)throw Error("Signing wallet not found.");let d=s.chainId??Number(u.chainId.split(":")[1]);if(0===d)l={chainId:0,address:s.contractAddress,nonce:s.nonce??0};else{let e=o.find((e=>e.id===d));if(!e)throw Error("Error, chain not configured in PrivyProvider config");let t=Fe({account:c,chain:e,transport:Le(G(e,a,n))});l=await t.prepareAuthorization({...s})}let h=await u.getEthereumProvider(),w=await h.request({method:"secp256k1_sign",params:[De(l)]});return{...l,...He(w)}}),[e,t,r,o])}},At=ft;function kt(e){let{signTypedData:t}=le(ye);return r("signTypedData",e),{signTypedData:t}}const Ct=()=>{let{isModalOpen:e}=le(ye);return{isOpen:e}};function vt(e){let{getAccessToken:t}=le(ye);return r("accessToken",e),{getAccessToken:t}}function Et(e){let{authenticated:t,user:a}=me(),{initLoginWithOAuth:o}=we(),n=H();return r("oAuthAuthorization",e),{reauthorize:e=>St(t,a,o,n,e.provider)}}let St=async(e,t,r,a,o)=>{if(!e)throw a("linkAccount","onError",he.MUST_BE_AUTHENTICATED,{linkMethod:o}),new de("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(o))))throw new de(`OAuth account of type ${o} not linked to the account.`);await r(o)};function Tt(e){let{client:t}=we(),[r,a]=ce({status:"initial"});return{linkWithCustomJwt:ne((async r=>{try{a({status:"initial"}),t.startAuthFlow(new J(r)),a({status:"loading"});let{user:o}=await t.link();if(!o)throw Error("Error, user not found");let n=o.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return a({status:"done"}),e?.onSuccess?.({user:o,linkMethod:"custom",linkedAccount:n}),{user:o}}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),r}}),[t.startAuthFlow,t.link]),state:r}}const Ut=e=>{let t=ee();return r("customAuth",e),{status:t}};function It({isAuthenticated:e,isLoading:t,...r}){let a=ue();ie((()=>{t||a.current?.()}),[e,t]);let o=ne((e=>(a.current=e,()=>{a.current=void 0})),[]);return te({...r,subscribe:o})}function Wt(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}=me();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}}const Rt=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=we();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},Pt=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=(()=>{let{user:e}=me(),t=we(),{signWithUserSigner:r}=fe(),a=async({wallet:a,additional_signers:o})=>{let n=await t.client.getAccessToken();if(!e||!n)throw new de("User must be authenticated and have an embedded wallet to delegate actions.");if(!a.id)throw new de("Wallet to add signers to must have ID on server");if(!t.walletProxy)throw new de("Wallet proxy not initialized.");await Ke(t.privy,{wallet_id:a.id},r,{additional_signers:o})};return{addSessionSignersInternal:async({address:r,signers:o})=>{let n=await t.client.getAccessToken();if(!e||!n)throw new de("User must be authenticated and have an embedded wallet to add a session signer.");let s=t.walletProxy??await t.initializeWalletProxy(15e3);if(!s)throw new de("Wallet proxy not initialized.");let i=Ae(e,r);if(!i)throw new de("Address to add signers too is not associated with current user.");if(ke(i)){if(0===o.length)throw new de("Must specify at least one signer to add.");let e=[...(await xe(t.privy,{wallet_id:i.id})).additional_signers,...re(o)];await a({wallet:i,additional_signers:e})}else{if(i.delegated)return{user:e};if(o.length>0)throw new de("Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let a=ae({address:r,user:e}),l=oe({address:r,user:e});await t.recoverEmbeddedWallet({address:r}),await s.createDelegatedAction({accessToken:n,rootWallet:l,delegatedWallets:[a]})}let l=await t.refreshSessionAndUser();if(!l)throw Error("Could not refresh user");return{user:l}},removeSessionSignersInternal:async({address:r})=>{let o=await t.client.getAccessToken();if(!e||!o)throw new de("User must be authenticated and have an embedded wallet to delegate actions.");if(!(t.walletProxy??await t.initializeWalletProxy(15e3)))throw new de("Wallet proxy not initialized.");let n=Ae(e,r);if(!n)throw new de("Address to remove signers from is not associated with current user.");ke(n)?await a({wallet:n,additional_signers:[]}):await t.client.revokeDelegatedWallet();let s=await t.refreshSessionAndUser();if(!s)throw Error("Could not refresh user");return{user:s}}}})();return{addSessionSigners:async({address:t,signers:r})=>e({address:t,signers:r}),removeSessionSigners:async({address:e})=>t({address:e})}},bt=()=>{let{signWithUserSigner:e}=fe();return se((()=>({async generateAuthorizationSignature(t){let{signature:r}=await qe(e,t);return{signature:r}}})),[e])},Mt=()=>{let{setUser:e,client:t}=le(pe),{user:r}=le(ye);return{user:r,refreshUser:ne((async()=>{let r=await(t?.updateUserAndIdToken());return e(r??null),r}),[t,e])}},Nt=e=>{let t=o(),{initLoginWithTelegram:r,loginWithTelegram:a,telegramAuthState:n,setTelegramAuthState:i}=we();return{login:ne((async o=>{try{if(t.enabled&&"success"!==t.status)throw new s(t.error,null,he.CAPTCHA_FAILURE);await r(t.token,o?.disableSignup);let{user:n,isNewUser:i,loginAccount:l,wasAlreadyAuthenticated:c}=await a({intent:"login"});e?.onComplete?.({user:n,isNewUser:i,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:l})}catch(o){throw i({status:"error",error:o}),e?.onError?.(o.privyErrorCode||he.UNKNOWN_AUTH_ERROR),o}}),[r,a,t]),state:n}},Ot=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=we();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},_t=async({wallet:e})=>{let t=await e.getEthereumProvider();return je({address:e.address,sign:async({hash:r})=>{if("privy"!==e.walletClientType)throw new ze({error:"Unprefixed signing is not supported by external wallets.",code:"unsupported_wallet_type"});return await t.request({method:"secp256k1_sign",params:[r]})},signMessage:async({message:r})=>await t.request({method:"personal_sign",params:[r,e.address]}),signTypedData:async r=>await t.request({method:"eth_signTypedData_v4",params:[e.address,r]}),signTransaction:async e=>await t.request({method:"eth_signTransaction",params:[e]})})};export{_t as toViemAccount,ct as useAuthMfa,dt as useAuthMfaEnrollment,bt as useAuthorizationSignature,lt as useBaseAccountSdk,it as useConnectBaseAccount,st as useConnectCoinbaseSmartWallet,Ze as useConnectOrCreateWallet,ht as useCrossAppAccounts,Ut as useCustomAuth,Rt as useDelegatedActions,Wt as useFarcasterSigner,mt as useGuestAccounts,Ot as useHeadlessDelegatedActions,at as useLinkAccount,Tt as useLinkJwtAccount,Je as useLinkWithPasskey,et as useLinkWithSiwe,$e as useLoginWithEmail,Be as useLoginWithFarcasterV2,Ge as useLoginWithOAuth,Xe as useLoginWithPasskey,tt as useLoginWithSiwe,Ye as useLoginWithSms,Nt as useLoginWithTelegram,Ct as useModalStatus,Et as useOAuthTokens,Ve as useRecoverEmbeddedWallet,wt as useSendTransaction,Pt as useSessionSigners,pt as useSetWalletPassword,yt as useSetWalletRecovery,ft as useSign7702Authorization,At as useSignAuthorization,gt as useSignMessage,rt as useSignTransaction,kt as useSignTypedData,Qe as useSignupWithPasskey,It as useSubscribeToJwtAuthWithFlag,te as useSyncJwtBasedAuthState,vt as useToken,ot as useUpdateAccount,nt as useUpdateEmail,Mt as useUser,B as useWallets};
