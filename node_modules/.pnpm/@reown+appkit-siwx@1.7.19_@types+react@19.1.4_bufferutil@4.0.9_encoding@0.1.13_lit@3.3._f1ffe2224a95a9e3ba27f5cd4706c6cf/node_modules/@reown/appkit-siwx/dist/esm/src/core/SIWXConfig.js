/**
 * This is the base class for a SIWX config.
 * You may extend this class to create your own configuration replacing the default logic.
 */
export class SIWXConfig {
    constructor(params) {
        this.messenger = params.messenger;
        this.verifiers = params.verifiers;
        this.storage = params.storage;
        this.required = params.required ?? true;
    }
    /**
     * Uses the messenger to create a message.
     *
     * @param input SIWXMessage.Input
     * @returns Promise<SIWXMessage>
     */
    createMessage(input) {
        return this.messenger.createMessage(input);
    }
    /**
     * Combine the verifiers to verify the session and storage to store it.
     * It will throw an error if the session is not valid.
     *
     * @param session SIWXSession
     * @returns Promise<void>
     */
    async addSession(session) {
        const isValid = await this.verifySession(session);
        if (!isValid) {
            throw new Error('The signature is not valid');
        }
        return this.storage.add(session);
    }
    /**
     * Combine the verifiers to verify the sessions and storage to store all of them.
     * It will throw an error if any of the sessions is not valid.
     *
     * @param chainId CaipNetworkId
     * @param address string
     * @returns Promise<SIWXSession[]>
     */
    async setSessions(sessions) {
        const verifications = await Promise.all(sessions.map(session => this.verifySession(session)));
        const invalidSession = sessions.find((_, index) => !verifications[index]);
        if (invalidSession) {
            throw new Error('The signature is not valid', { cause: invalidSession });
        }
        return this.storage.set(sessions);
    }
    /**
     * Get the sessions from the storage and verify them.
     * If the session is not valid, it will be removed from the storage.
     *
     * @param chainId CaipNetworkId
     * @param address string
     * @returns Promise<SIWXSession[]>
     */
    async getSessions(chainId, address) {
        const sessions = await this.storage.get(chainId, address);
        const verifications = await Promise.all(sessions.map(async (session) => {
            if (await this.verifySession(session)) {
                return true;
            }
            await this.storage.delete(session.data.chainId, session.data.accountAddress);
            return false;
        }));
        return sessions.filter((_, index) => verifications[index]);
    }
    /**
     * Remove the session from the storage.
     *
     * @param chainId CaipNetworkId
     * @param address string
     * @returns Promise<void>
     */
    async revokeSession(chainId, address) {
        return this.storage.delete(chainId, address);
    }
    /**
     * This method should verify the session.
     * It will first check if the verifier should verify the session and then call the verify method.
     * It will return `true` if the session is valid for all verifications and there is at least one verification.
     *
     * @param session SIWXSession
     * @returns Promise<boolean> - If `true` means the session is valid.
     */
    async verifySession(session) {
        const chainVerifiers = this.verifiers.filter(verifier => verifier.shouldVerify(session));
        const verifications = await Promise.all(chainVerifiers.map(verifier => verifier.verify(session)));
        return verifications.length > 0 && verifications.every(result => result);
    }
    /**
     * This method determines whether the wallet stays connected when the user denies the signature request.
     *
     * @returns {boolean}
     */
    getRequired() {
        return this.required;
    }
}
//# sourceMappingURL=SIWXConfig.js.map